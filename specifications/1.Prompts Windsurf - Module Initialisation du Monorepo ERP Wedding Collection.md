# Prompts Windsurf - Module Initialisation du Monorepo ERP Wedding Collection

## 📋 Informations du Module

- **Module** : Initialisation du Monorepo ERP Wedding Collection
- **Identifiant technique** : `monorepo_initialization`
- **Version** : 0.1.0
- **Priorité** : P0 (Critique - Fondation du projet)
- **Dépendances** : Aucune (module de base)
- **Applications concernées** : Toutes (backoffice, client-portal, vendor-portal, public-site)

---

## 🎯 Vue d'Ensemble du Module

Ce module constitue la fondation technique absolue de l'ERP Wedding Collection. Il établit l'architecture monorepo, les configurations standardisées, les packages partagés et les workflows de développement qui seront utilisés par tous les autres modules du système.

L'initialisation correcte de ce module est critique car elle détermine la qualité, la cohérence et la maintenabilité de l'ensemble du projet. Chaque prompt doit être exécuté avec la plus grande attention aux détails et en respectant scrupuleusement les conventions établies.

---

## 🚀 Section 1 : Initialisation

### 01 - Création de la structure racine du monorepo

🎯 **But clair**
Créer la structure de répertoires racine du monorepo ERP Wedding Collection avec l'organisation standardisée des dossiers apps/, packages/, supabase/, docs/ et scripts/.

🧠 **Contexte technique**
Cette structure constitue la fondation organisationnelle du projet. Elle doit respecter les meilleures pratiques des monorepos et faciliter la navigation, la maintenance et l'évolutivité. La structure sera utilisée par tous les développeurs et outils du projet.

🛠️ **Type de fichier concerné**
Structure de dossiers, `.gitignore`, `README.md`

🔄 **Comportement attendu / Logique métier**
- Créer la hiérarchie complète des dossiers selon les spécifications
- Initialiser les fichiers de configuration racine (.gitignore, README.md)
- Établir les conventions de nommage et d'organisation
- Préparer l'environnement pour les npm workspaces
- Documenter la structure dans le README principal

⚙️ **Interactions avec d'autres modules**
- Aucune dépendance (module fondamental)
- Sera utilisé par : tous les modules futurs
- Définit l'organisation pour : applications, packages partagés, documentation

💡 **Tips Windsurf**
- Utiliser le terminal intégré pour créer la structure de dossiers
- Configurer les Memories avec la structure du projet pour optimiser les suggestions
- Créer un README.md détaillé pour documenter l'organisation
- Initialiser Git si ce n'est pas déjà fait

---

### 02 - Configuration du package.json racine avec npm workspaces

🎯 **But clair**
Configurer le package.json racine du monorepo avec npm workspaces, les scripts de base et les dépendances partagées pour gérer efficacement l'ensemble du projet.

🧠 **Contexte technique**
Le package.json racine est le point central de gestion des dépendances et des scripts du monorepo. Il utilise npm workspaces pour gérer les relations entre les différents packages et applications, permettant une gestion unifiée des dépendances et des commandes.

🛠️ **Type de fichier concerné**
`package.json`

🔄 **Comportement attendu / Logique métier**
- Configurer npm workspaces pour apps/* et packages/*
- Définir les scripts racine (dev, build, test, lint, format)
- Ajouter les dépendances de développement partagées
- Configurer les métadonnées du projet
- Établir les conventions de versionnement

⚙️ **Interactions avec d'autres modules**
- Gère les dépendances de : toutes les applications et packages
- Utilisé par : scripts de développement, CI/CD
- Référence : packages partagés via workspace:*

💡 **Tips Windsurf**
- Utiliser npm workspaces pour optimiser la gestion des dépendances
- Configurer des scripts qui fonctionnent sur tous les workspaces
- Ajouter Prettier comme dépendance partagée
- Tester la configuration avec npm install

---

### 03 - Configuration TypeScript globale avec packages/tsconfig

🎯 **But clair**
Créer le package packages/tsconfig avec les configurations TypeScript de base (base.json, react.json, node.json) qui seront étendues par toutes les applications et packages du monorepo.

🧠 **Contexte technique**
Ce package centralise les configurations TypeScript pour assurer la cohérence du typage à travers tout le projet. Il fournit des configurations de base qui peuvent être étendues selon les besoins spécifiques de chaque application ou package.

🛠️ **Type de fichier concerné**
`.json`, `package.json`

🔄 **Comportement attendu / Logique métier**
- Créer base.json avec configuration TypeScript stricte
- Créer react.json pour les applications React
- Créer node.json pour les scripts et outils Node.js
- Configurer les chemins d'alias et résolution de modules
- Établir les règles de typage strict

⚙️ **Interactions avec d'autres modules**
- Utilisé par : toutes les applications et packages
- Étendu par : configurations spécifiques de chaque workspace
- Intègre : règles de typage pour React, Node.js, DOM

💡 **Tips Windsurf**
- Utiliser des configurations strictes pour améliorer la qualité du code
- Configurer les alias de chemins pour faciliter les imports
- Tester les configurations avec des fichiers TypeScript simples
- Documenter les différentes configurations disponibles

---

### 04 - Configuration ESLint globale avec packages/eslint-config

🎯 **But clair**
Créer le package packages/eslint-config avec les règles ESLint standardisées pour React, TypeScript, accessibilité et bonnes pratiques qui seront utilisées par toutes les applications.

🧠 **Contexte technique**
Ce package centralise les règles de linting pour assurer la qualité et la cohérence du code à travers tout le projet. Il intègre les meilleures pratiques pour React, TypeScript, l'accessibilité et la sécurité.

🛠️ **Type de fichier concerné**
`.js`, `package.json`

🔄 **Comportement attendu / Logique métier**
- Configurer les règles ESLint pour React et TypeScript
- Intégrer les règles d'accessibilité (eslint-plugin-jsx-a11y)
- Ajouter les règles de sécurité et bonnes pratiques
- Configurer les règles spécifiques au projet
- Permettre l'extension par les applications

⚙️ **Interactions avec d'autres modules**
- Utilisé par : toutes les applications et packages
- Intègre : règles React, TypeScript, accessibilité
- Compatible avec : Prettier, VS Code

💡 **Tips Windsurf**
- Utiliser des règles strictes mais pragmatiques
- Intégrer les plugins essentiels (React, TypeScript, a11y)
- Configurer les règles pour éviter les conflits avec Prettier
- Tester la configuration sur du code existant

---

### 05 - Configuration Prettier globale

🎯 **But clair**
Configurer Prettier au niveau racine du monorepo avec les règles de formatage standardisées qui seront appliquées à tous les fichiers du projet pour assurer une cohérence visuelle.

🧠 **Contexte technique**
Prettier assure un formatage cohérent du code à travers tout le projet. La configuration globale évite les conflits entre les différents packages et garantit une expérience de développement uniforme.

🛠️ **Type de fichier concerné**
`.prettierrc.js`, `.prettierignore`

🔄 **Comportement attendu / Logique métier**
- Configurer les règles de formatage (indentation, quotes, etc.)
- Définir les extensions de fichiers à formater
- Exclure les dossiers générés (dist, node_modules)
- Intégrer avec ESLint pour éviter les conflits
- Configurer les scripts de formatage

⚙️ **Interactions avec d'autres modules**
- Appliqué à : tous les fichiers du projet
- Intégré avec : ESLint, VS Code, scripts npm
- Compatible avec : TypeScript, React, JSON, Markdown

💡 **Tips Windsurf**
- Utiliser des règles cohérentes avec les standards de l'équipe
- Configurer l'intégration avec VS Code
- Ajouter des scripts npm pour le formatage automatique
- Tester sur différents types de fichiers

---

### 06 - Création du package shared-ui avec composants de base

🎯 **But clair**
Créer le package packages/shared-ui avec la structure de base, la configuration Tailwind CSS et les premiers composants UI réutilisables (Button, Input, Card) qui seront utilisés par toutes les applications.

🧠 **Contexte technique**
Ce package constitue la bibliothèque de composants UI du projet. Il utilise Tailwind CSS pour le stylisme et fournit des composants cohérents et réutilisables. Il est essentiel pour maintenir la cohérence visuelle à travers toutes les applications.

🛠️ **Type de fichier concerné**
`.tsx`, `.ts`, `package.json`, `tailwind.config.js`

🔄 **Comportement attendu / Logique métier**
- Créer la structure du package avec src/components/
- Configurer Tailwind CSS avec le thème du projet
- Implémenter les composants Button, Input, Card
- Créer les tests unitaires pour chaque composant
- Configurer l'export des composants via index.ts

⚙️ **Interactions avec d'autres modules**
- Utilisé par : toutes les applications du monorepo
- Dépend de : React, Tailwind CSS, TypeScript
- Fournit : composants UI standardisés

💡 **Tips Windsurf**
- Utiliser Tailwind CSS pour un stylisme cohérent
- Créer des composants flexibles avec des props bien typées
- Implémenter les tests avec React Testing Library
- Documenter les composants avec des exemples d'usage

---

### 07 - Création du package shared-logic avec utilitaires de base

🎯 **But clair**
Créer le package packages/shared-logic avec les fonctions utilitaires de base (formatage de dates, validation, gestion d'erreurs) qui seront réutilisées par toutes les applications.

🧠 **Contexte technique**
Ce package centralise la logique métier et les utilitaires partagés pour éviter la duplication de code et assurer la cohérence fonctionnelle. Il fournit des fonctions pures et testables qui peuvent être utilisées dans différents contextes.

🛠️ **Type de fichier concerné**
`.ts`, `package.json`

🔄 **Comportement attendu / Logique métier**
- Créer la structure avec src/date/, src/validation/, src/error/
- Implémenter les fonctions de formatage de dates
- Créer les fonctions de validation de formulaires
- Développer le système de gestion d'erreurs
- Configurer l'export des fonctions via index.ts

⚙️ **Interactions avec d'autres modules**
- Utilisé par : toutes les applications et autres packages
- Peut dépendre de : bibliothèques utilitaires (date-fns, zod)
- Fournit : logique métier réutilisable

💡 **Tips Windsurf**
- Créer des fonctions pures et facilement testables
- Utiliser TypeScript pour un typage strict
- Implémenter des tests unitaires complets
- Documenter les fonctions avec JSDoc

---

### 08 - Création du package types avec interfaces de base

🎯 **But clair**
Créer le package packages/types avec les types TypeScript partagés (User, Client, Event, API responses) qui assureront la cohérence des types à travers toutes les applications.

🧠 **Contexte technique**
Ce package centralise tous les types TypeScript partagés pour éviter la duplication et assurer la cohérence. Il définit les interfaces des entités métier, des réponses API et des structures de données communes.

🛠️ **Type de fichier concerné**
`.ts`, `package.json`

🔄 **Comportement attendu / Logique métier**
- Créer la structure avec src/entities/, src/api/, src/auth/
- Définir les interfaces des entités métier principales
- Créer les types pour les réponses et requêtes API
- Établir les types d'authentification et autorisation
- Configurer l'export des types via index.ts

⚙️ **Interactions avec d'autres modules**
- Utilisé par : toutes les applications et packages
- Synchronisé avec : schémas Supabase
- Référencé par : api-client, shared-logic

💡 **Tips Windsurf**
- Utiliser des interfaces plutôt que des types quand possible
- Créer des types génériques réutilisables
- Synchroniser avec les types générés par Supabase
- Organiser les types par domaine fonctionnel

---

## 🏗️ Section 2 : Fonctionnalités Principales

### 09 - Configuration de l'application Backoffice

🎯 **But clair**
Créer et configurer l'application apps/backoffice avec Next.js 14 (app directory), Vite, Tailwind CSS et l'intégration des packages partagés pour l'interface d'administration.

🧠 **Contexte technique**
L'application Backoffice est l'interface d'administration principale de l'ERP. Elle utilise Next.js 14 avec l'architecture app directory et intègre tous les packages partagés. Elle servira de modèle pour les autres applications.

🛠️ **Type de fichier concerné**
`.tsx`, `.ts`, `package.json`, `vite.config.ts`, `tailwind.config.js`

🔄 **Comportement attendu / Logique métier**
- Initialiser le projet Next.js 14 avec app directory
- Configurer Vite comme bundler
- Intégrer Tailwind CSS avec la configuration partagée
- Ajouter les dépendances aux packages partagés
- Créer la structure de dossiers standardisée

⚙️ **Interactions avec d'autres modules**
- Utilise : shared-ui, shared-logic, types, api-client
- Dépend de : configurations partagées (ESLint, TypeScript)
- Port de développement : 3000

💡 **Tips Windsurf**
- Utiliser Next.js 14 avec l'architecture app directory
- Configurer les alias de chemins pour faciliter les imports
- Intégrer les packages partagés via workspace:*
- Tester la configuration avec une page simple

---

### 10 - Configuration de l'application Client Portal

🎯 **But clair**
Créer et configurer l'application apps/client-portal avec la même stack technique que le Backoffice mais adaptée aux besoins des clients avec un thème et une navigation spécifiques.

🧠 **Contexte technique**
Le Client Portal est l'interface dédiée aux clients pour consulter leurs événements, factures et communiquer avec l'équipe. Il partage la même base technique que le Backoffice mais avec une interface adaptée.

🛠️ **Type de fichier concerné**
`.tsx`, `.ts`, `package.json`, `vite.config.ts`, `tailwind.config.js`

🔄 **Comportement attendu / Logique métier**
- Dupliquer la configuration du Backoffice
- Adapter le port de développement (3001)
- Personnaliser la configuration Tailwind pour le thème client
- Créer la structure de navigation spécifique aux clients
- Intégrer les mêmes packages partagés

⚙️ **Interactions avec d'autres modules**
- Utilise : shared-ui, shared-logic, types, api-client
- Partage : configurations de base avec Backoffice
- Port de développement : 3001

💡 **Tips Windsurf**
- Réutiliser la configuration du Backoffice comme base
- Personnaliser uniquement les éléments spécifiques aux clients
- Maintenir la cohérence avec les autres applications
- Configurer un thème Tailwind spécifique

---

### 11 - Configuration de l'application Vendor Portal

🎯 **But clair**
Créer et configurer l'application apps/vendor-portal pour les prestataires avec la même base technique mais une interface et des fonctionnalités adaptées à leurs besoins spécifiques.

🧠 **Contexte technique**
Le Vendor Portal permet aux prestataires de gérer leurs services, consulter leurs missions et communiquer avec l'équipe. Il utilise la même architecture que les autres applications mais avec une interface dédiée.

🛠️ **Type de fichier concerné**
`.tsx`, `.ts`, `package.json`, `vite.config.ts`, `tailwind.config.js`

🔄 **Comportement attendu / Logique métier**
- Créer l'application basée sur la configuration standard
- Configurer le port de développement (3002)
- Adapter l'interface pour les besoins des prestataires
- Intégrer les packages partagés
- Créer la navigation spécifique aux vendors

⚙️ **Interactions avec d'autres modules**
- Utilise : shared-ui, shared-logic, types, api-client
- Partage : configurations de base
- Port de développement : 3002

💡 **Tips Windsurf**
- Maintenir la cohérence architecturale avec les autres apps
- Adapter uniquement l'interface utilisateur
- Réutiliser au maximum les composants partagés
- Configurer les permissions spécifiques aux vendors

---

### 12 - Configuration de l'application Public Site

🎯 **But clair**
Créer et configurer l'application apps/public-site pour le site vitrine public avec optimisations SEO, performance et une interface marketing adaptée.

🧠 **Contexte technique**
Le Public Site est la vitrine publique de l'entreprise. Il nécessite des optimisations spécifiques pour le SEO, les performances et l'expérience utilisateur. Il utilise la même base technique mais avec des adaptations pour le public.

🛠️ **Type de fichier concerné**
`.tsx`, `.ts`, `package.json`, `vite.config.ts`, `tailwind.config.js`

🔄 **Comportement attendu / Logique métier**
- Créer l'application avec optimisations SEO
- Configurer le port de développement (3003)
- Adapter l'interface pour le grand public
- Optimiser les performances et le chargement
- Intégrer les packages partagés appropriés

⚙️ **Interactions avec d'autres modules**
- Utilise : shared-ui (sélectif), shared-logic, types
- Optimisé pour : SEO, performances, accessibilité
- Port de développement : 3003

💡 **Tips Windsurf**
- Optimiser pour les performances et le SEO
- Utiliser sélectivement les packages partagés
- Configurer les métadonnées et le sitemap
- Implémenter le lazy loading pour les images

---

### 13 - Création du package api-client avec client Supabase

🎯 **But clair**
Créer le package packages/api-client avec la configuration du client Supabase, les fonctions d'authentification et les wrappers pour les opérations CRUD de base.

🧠 **Contexte technique**
Ce package centralise toutes les interactions avec Supabase pour assurer la cohérence et faciliter la maintenance. Il fournit une interface unifiée pour l'authentification, les requêtes de base de données et la gestion des erreurs.

🛠️ **Type de fichier concerné**
`.ts`, `package.json`

🔄 **Comportement attendu / Logique métier**
- Configurer le client Supabase avec les variables d'environnement
- Créer les fonctions d'authentification (login, logout, signup)
- Implémenter les wrappers CRUD génériques
- Gérer les erreurs et les réponses API
- Configurer les types TypeScript pour Supabase

⚙️ **Interactions avec d'autres modules**
- Utilisé par : toutes les applications
- Dépend de : @supabase/supabase-js, types package
- Intègre : gestion d'erreurs, authentification

💡 **Tips Windsurf**
- Utiliser les types générés par Supabase
- Implémenter une gestion d'erreurs robuste
- Créer des fonctions réutilisables et typées
- Configurer les variables d'environnement

---

### 14 - Configuration des scripts npm globaux

🎯 **But clair**
Configurer les scripts npm au niveau racine et dans chaque application pour le développement, les tests, le build et le déploiement avec des commandes unifiées et efficaces.

🧠 **Contexte technique**
Les scripts npm facilitent les tâches de développement quotidiennes et l'automatisation. Ils doivent être cohérents entre les applications et permettre d'exécuter des commandes sur l'ensemble du monorepo ou sur des packages spécifiques.

🛠️ **Type de fichier concerné**
`package.json`

🔄 **Comportement attendu / Logique métier**
- Configurer les scripts racine (dev, build, test, lint)
- Créer des scripts spécifiques par application
- Implémenter des scripts de maintenance (clean, reset)
- Configurer les scripts de déploiement
- Optimiser les performances des scripts

⚙️ **Interactions avec d'autres modules**
- Exécute : commandes sur tous les workspaces
- Utilise : npm workspaces, outils de build
- Intègre : linting, testing, formatting

💡 **Tips Windsurf**
- Utiliser npm workspaces pour les commandes globales
- Créer des scripts parallèles pour améliorer les performances
- Implémenter des scripts de nettoyage et maintenance
- Documenter les scripts dans le README

---

## 🔧 Section 3 : Fonctionnalités Secondaires

### 15 - Configuration des tests avec Jest et React Testing Library

🎯 **But clair**
Configurer Jest et React Testing Library pour tous les packages et applications avec des configurations partagées, des utilitaires de test et des exemples de tests pour assurer la qualité du code.

🧠 **Contexte technique**
Les tests sont essentiels pour maintenir la qualité et la fiabilité du code. La configuration doit être cohérente entre tous les packages et faciliter l'écriture de tests unitaires et d'intégration.

🛠️ **Type de fichier concerné**
`.js`, `.ts`, `.test.tsx`, `package.json`

🔄 **Comportement attendu / Logique métier**
- Configurer Jest avec support TypeScript et React
- Intégrer React Testing Library pour les tests de composants
- Créer des utilitaires de test partagés
- Configurer la couverture de code
- Implémenter des exemples de tests

⚙️ **Interactions avec d'autres modules**
- Appliqué à : tous les packages et applications
- Intègre : TypeScript, React, DOM testing
- Utilise : configurations partagées

💡 **Tips Windsurf**
- Configurer Jest avec des presets appropriés
- Créer des utilitaires de test réutilisables
- Implémenter des tests pour les composants partagés
- Configurer la couverture de code avec des seuils

---

### 16 - Configuration de Storybook pour la documentation des composants

🎯 **But clair**
Configurer Storybook pour le package shared-ui afin de documenter et tester visuellement les composants UI avec des stories interactives et une documentation automatique.

🧠 **Contexte technique**
Storybook facilite le développement, les tests et la documentation des composants UI. Il permet de développer les composants en isolation et de créer une documentation vivante pour l'équipe.

🛠️ **Type de fichier concerné**
`.js`, `.ts`, `.stories.tsx`, `package.json`

🔄 **Comportement attendu / Logique métier**
- Configurer Storybook pour React et TypeScript
- Créer des stories pour les composants existants
- Intégrer avec Tailwind CSS
- Configurer les addons essentiels (controls, docs)
- Automatiser la génération de documentation

⚙️ **Interactions avec d'autres modules**
- Appliqué à : package shared-ui
- Intègre : React, TypeScript, Tailwind CSS
- Génère : documentation interactive

💡 **Tips Windsurf**
- Utiliser les addons essentiels pour une meilleure expérience
- Créer des stories complètes avec tous les variants
- Intégrer avec la configuration Tailwind existante
- Configurer le déploiement automatique de Storybook

---

### 17 - Configuration de Husky et lint-staged pour les hooks Git

🎯 **But clair**
Configurer Husky et lint-staged pour automatiser les vérifications de qualité du code (linting, formatting, tests) avant chaque commit et push pour maintenir la qualité du code.

🧠 **Contexte technique**
Les hooks Git automatisent les vérifications de qualité et empêchent l'introduction de code non conforme dans le repository. Ils améliorent la qualité globale du projet et réduisent les erreurs.

🛠️ **Type de fichier concerné**
`.js`, `package.json`, scripts Git hooks

🔄 **Comportement attendu / Logique métier**
- Configurer Husky pour les hooks pre-commit et pre-push
- Configurer lint-staged pour les fichiers modifiés
- Automatiser le linting et le formatting
- Exécuter les tests sur les fichiers modifiés
- Configurer les messages d'erreur informatifs

⚙️ **Interactions avec d'autres modules**
- Appliqué à : tous les fichiers du projet
- Utilise : ESLint, Prettier, Jest
- Intègre : workflow Git

💡 **Tips Windsurf**
- Configurer des vérifications rapides pour ne pas ralentir le workflow
- Utiliser lint-staged pour optimiser les performances
- Créer des messages d'erreur clairs et informatifs
- Permettre le bypass en cas d'urgence

---

### 18 - Configuration des variables d'environnement

🎯 **But clair**
Configurer la gestion des variables d'environnement pour toutes les applications avec des fichiers .env.example, la validation des variables et la documentation des configurations requises.

🧠 **Contexte technique**
Les variables d'environnement permettent de configurer les applications selon l'environnement (développement, test, production). Elles doivent être bien documentées et validées pour éviter les erreurs de configuration.

🛠️ **Type de fichier concerné**
`.env.example`, `.ts`, `package.json`

🔄 **Comportement attendu / Logique métier**
- Créer des fichiers .env.example pour chaque application
- Implémenter la validation des variables d'environnement
- Documenter toutes les variables requises
- Configurer les variables par défaut pour le développement
- Créer des utilitaires de configuration

⚙️ **Interactions avec d'autres modules**
- Utilisé par : toutes les applications
- Configure : Supabase, APIs externes, build
- Intègre : validation, documentation

💡 **Tips Windsurf**
- Utiliser des bibliothèques de validation (zod, joi)
- Créer des fichiers .env.example complets
- Documenter chaque variable dans le README
- Implémenter des valeurs par défaut sécurisées

---

## 🚀 Section 4 : Évolutions Futures

### 19 - Configuration Docker pour le développement

🎯 **But clair**
Créer des configurations Docker et Docker Compose pour standardiser l'environnement de développement et faciliter l'onboarding des nouveaux développeurs avec un environnement reproductible.

🧠 **Contexte technique**
Docker permet de créer un environnement de développement standardisé et reproductible. Cette configuration facilitera l'onboarding des nouveaux développeurs et réduira les problèmes liés aux différences d'environnement.

🛠️ **Type de fichier concerné**
`Dockerfile`, `docker-compose.yml`, `.dockerignore`

🔄 **Comportement attendu / Logique métier**
- Créer des Dockerfiles pour chaque application
- Configurer Docker Compose pour l'ensemble du stack
- Optimiser les images pour le développement
- Configurer les volumes pour le hot reload
- Documenter l'utilisation de Docker

⚙️ **Interactions avec d'autres modules**
- Encapsule : toutes les applications et services
- Intègre : base de données, services externes
- Facilite : développement, tests, déploiement

💡 **Tips Windsurf**
- Utiliser des images de base optimisées
- Configurer le multi-stage build pour la production
- Optimiser les layers Docker pour le cache
- Documenter les commandes Docker essentielles

---

### 20 - Configuration de Turborepo pour l'optimisation des builds

🎯 **But clair**
Intégrer Turborepo pour optimiser les builds et les tests du monorepo avec la mise en cache intelligente, l'exécution parallèle et l'optimisation des dépendances.

🧠 **Contexte technique**
Turborepo optimise les performances des monorepos en gérant intelligemment la mise en cache et l'exécution parallèle des tâches. Il améliore significativement les temps de build et de test.

🛠️ **Type de fichier concerné**
`turbo.json`, `package.json`

🔄 **Comportement attendu / Logique métier**
- Configurer Turborepo avec les pipelines de build
- Optimiser la mise en cache des builds
- Configurer l'exécution parallèle des tâches
- Intégrer avec les scripts npm existants
- Optimiser les dépendances entre packages

⚙️ **Interactions avec d'autres modules**
- Optimise : builds, tests, linting
- Intègre : npm workspaces, scripts existants
- Améliore : performances, temps de développement

💡 **Tips Windsurf**
- Configurer des pipelines optimisés pour chaque type de tâche
- Utiliser la mise en cache remote pour les équipes
- Optimiser les dépendances entre packages
- Mesurer les gains de performance

---

### 21 - Configuration de Renovate pour les mises à jour automatiques

🎯 **But clair**
Configurer Renovate Bot pour automatiser les mises à jour des dépendances avec des règles intelligentes, des tests automatiques et une gestion des versions sécurisée.

🧠 **Contexte technique**
Renovate automatise la maintenance des dépendances en créant des pull requests pour les mises à jour. Il aide à maintenir le projet à jour tout en contrôlant les risques liés aux mises à jour.

🛠️ **Type de fichier concerné**
`renovate.json`, `.github/workflows/`

🔄 **Comportement attendu / Logique métier**
- Configurer Renovate avec des règles appropriées
- Automatiser les tests sur les mises à jour
- Grouper les mises à jour par type et importance
- Configurer les auto-merge pour les mises à jour mineures
- Intégrer avec les workflows CI/CD

⚙️ **Interactions avec d'autres modules**
- Maintient : toutes les dépendances du projet
- Intègre : CI/CD, tests automatiques
- Améliore : sécurité, maintenance

💡 **Tips Windsurf**
- Configurer des règles de groupement intelligentes
- Automatiser les tests sur les pull requests
- Utiliser l'auto-merge pour les mises à jour sûres
- Surveiller les vulnérabilités de sécurité

---

### 22 - Configuration de Chromatic pour les tests visuels

🎯 **But clair**
Intégrer Chromatic pour automatiser les tests visuels des composants Storybook et détecter les régressions visuelles avec des captures d'écran automatiques et des comparaisons.

🧠 **Contexte technique**
Chromatic automatise les tests visuels en prenant des captures d'écran des composants et en détectant les changements visuels. Il aide à maintenir la cohérence visuelle et à détecter les régressions.

🛠️ **Type de fichier concerné**
`.js`, `package.json`, `.github/workflows/`

🔄 **Comportement attendu / Logique métier**
- Configurer Chromatic avec Storybook
- Automatiser les captures d'écran des composants
- Configurer la détection de régressions visuelles
- Intégrer avec les workflows CI/CD
- Configurer les seuils de tolérance

⚙️ **Interactions avec d'autres modules**
- Intègre : Storybook, shared-ui
- Automatise : tests visuels, détection de régressions
- Améliore : qualité visuelle, cohérence

💡 **Tips Windsurf**
- Configurer des baselines visuelles stables
- Automatiser les tests sur les pull requests
- Configurer des seuils de tolérance appropriés
- Intégrer avec les reviews de code

---

### 23 - Configuration de Sentry pour le monitoring d'erreurs

🎯 **But clair**
Intégrer Sentry dans toutes les applications pour le monitoring des erreurs en temps réel, le tracking des performances et l'alerting automatique avec des dashboards détaillés.

🧠 **Contexte technique**
Sentry fournit un monitoring complet des erreurs et des performances en production. Il aide à détecter et résoudre rapidement les problèmes, améliorant la stabilité et l'expérience utilisateur.

🛠️ **Type de fichier concerné**
`.ts`, `.tsx`, `package.json`

🔄 **Comportement attendu / Logique métier**
- Configurer Sentry dans chaque application
- Implémenter le tracking des erreurs et performances
- Configurer les alertes et notifications
- Intégrer avec les workflows de déploiement
- Créer des dashboards de monitoring

⚙️ **Interactions avec d'autres modules**
- Monitore : toutes les applications
- Intègre : déploiements, alerting
- Améliore : stabilité, debugging

💡 **Tips Windsurf**
- Configurer des environnements séparés pour dev/prod
- Implémenter des filtres pour réduire le bruit
- Configurer des alertes intelligentes
- Intégrer avec les outils de communication (Slack)

---

### 24 - Configuration de GitHub Actions pour CI/CD avancé

🎯 **But clair**
Créer des workflows GitHub Actions avancés pour l'intégration continue, les déploiements automatiques, les tests de sécurité et la gestion des releases avec des pipelines optimisés.

🧠 **Contexte technique**
GitHub Actions automatise l'ensemble du cycle de développement depuis les tests jusqu'au déploiement. Les workflows avancés incluent la parallélisation, la mise en cache et l'intégration avec les services externes.

🛠️ **Type de fichier concerné**
`.yml`, `.github/workflows/`

🔄 **Comportement attendu / Logique métier**
- Créer des workflows pour CI/CD complets
- Configurer les tests automatiques et la sécurité
- Automatiser les déploiements par environnement
- Intégrer avec les outils de monitoring
- Optimiser les performances des pipelines

⚙️ **Interactions avec d'autres modules**
- Automatise : tests, builds, déploiements
- Intègre : tous les outils du projet
- Améliore : qualité, fiabilité, productivité

💡 **Tips Windsurf**
- Utiliser la mise en cache pour optimiser les performances
- Configurer des workflows parallèles
- Implémenter des déploiements progressifs
- Intégrer avec les outils de monitoring et alerting

---

## 📊 Matrice de Priorités et Dépendances

| Prompt | Priorité | Dépendances | Durée Estimée | Complexité |
|--------|----------|-------------|---------------|------------|
| 01-08  | P0       | Aucune      | 3-4 jours     | Moyenne    |
| 09-14  | P0       | 01-08       | 4-5 jours     | Moyenne    |
| 15-18  | P1       | 09-14       | 2-3 jours     | Faible     |
| 19-24  | P2-P3    | 15-18       | 1-2 semaines  | Élevée     |

---

## 🔄 Ordre d'Exécution Recommandé

### **Phase 1 - Fondations (Semaine 1)**
Prompts 01-08 : Structure de base, packages partagés, configurations

### **Phase 2 - Applications (Semaine 2)**
Prompts 09-14 : Configuration des 4 applications et api-client

### **Phase 3 - Qualité (Semaine 3)**
Prompts 15-18 : Tests, documentation, hooks Git, environnement

### **Phase 4 - Optimisations (Futures versions)**
Prompts 19-24 : Docker, Turborepo, monitoring, CI/CD avancé

---

## ⚠️ Points d'Attention Critiques

### **Cohérence Architecturale**
- Respecter scrupuleusement les conventions de nommage
- Maintenir la cohérence entre toutes les applications
- Valider chaque configuration avant de passer au prompt suivant

### **Gestion des Dépendances**
- Utiliser npm workspaces correctement
- Éviter les dépendances circulaires
- Tester les installations et builds régulièrement

### **Sécurité**
- Configurer les variables d'environnement correctement
- Ne jamais committer de secrets
- Valider toutes les configurations de sécurité

---

*Document généré par Manus AI - Expert en transformation de cahiers des charges pour Windsurf*

