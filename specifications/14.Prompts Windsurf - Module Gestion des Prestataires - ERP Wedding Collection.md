# Prompts Windsurf - Module Gestion des Prestataires - ERP Wedding Collection

## Vue d'Ensemble du Module

Le module Gestion des Prestataires représente le pilier stratégique de l'écosystème partenaires de l'ERP Wedding Collection, orchestrant l'ensemble du réseau de prestataires externes depuis leur onboarding jusqu'à la gestion des commissions et l'évaluation de leurs performances. Ce module sophistiqué illustre l'application avancée de notre méthodologie de génération de prompts Windsurf, transformant un cahier des charges technique exhaustif en instructions exécutables optimisées pour l'agent de développement.

La complexité de ce module réside dans sa nature transversale qui connecte tous les acteurs de l'écosystème Wedding Collection : les équipes internes via le Backoffice, les prestataires partenaires via le Vendor Portal, et les clients finaux via le Client Portal. Cette multi-dimensionnalité nécessite une architecture robuste qui garantit la cohérence des données, la sécurité des échanges, et l'efficacité des processus métier tout en maintenant une expérience utilisateur optimale pour chaque type d'utilisateur.

L'architecture du module s'appuie sur un schéma `bo_providers` dédié pour centraliser toutes les données relatives aux prestataires, utilisant une approche de séparation des responsabilités avec des services spécialisés pour chaque domaine fonctionnel. Cette stratégie garantit la performance des opérations de recherche et sélection, facilite la gestion des commissions complexes, et prépare l'évolution vers des fonctionnalités avancées comme l'IA de recommandation et l'automatisation des workflows.

La transformation de ce cahier des charges en prompts Windsurf suit notre méthodologie éprouvée, structurant le développement en quatre phases logiques qui optimisent l'efficacité de l'agent tout en maintenant la qualité et la robustesse du code généré. Chaque prompt intègre les spécificités métier identifiées dans l'analyse documentaire, les bonnes pratiques Windsurf, et les contraintes d'intégration multi-portails critiques pour un module de gestion de partenaires.

L'intégration avec les modules Événements, Contrats, et Comptabilité constitue un élément central de l'architecture, nécessitant une synchronisation sophistiquée des données de prestations, une coordination temps réel des commissions, et une robustesse face aux évolutions des règles métier. Cette intégration illustre parfaitement l'approche Windsurf d'orchestration de données complexes avec une logique métier partenariale cohérente.

---

## Section 1 : Initialisation

### Prompt 1.1 : Création du Schéma Prestataires Complet avec Multi-Portails

🎯 **But** : Créer le schéma complet de base de données pour le module Gestion des Prestataires avec toutes les tables, relations, contraintes métier, politiques RLS multi-portails, triggers de synchronisation, et intégration avec l'écosystème ERP

🧠 **Contexte** : Module central du schéma `bo_providers` avec isolation complète des données prestataires dans l'ERP Wedding Collection. Respecter impérativement les conventions définies dans `Conventions_Supabase_WeddingCollection_AgentIA.md` avec performance optimisée, gestion multi-portails, et intégration avec modules Événements, Contrats, Comptabilité, et Calendrier.

🛠️ **Fichiers** :
- `supabase/migrations/20241203_050_create_providers_schema.sql`
- `supabase/migrations/20241203_051_create_providers_tables.sql`
- `supabase/migrations/20241203_052_create_provider_categories_schema.sql`
- `supabase/migrations/20241203_053_create_provider_services_schema.sql`
- `supabase/migrations/20241203_054_create_provider_commissions_schema.sql`
- `supabase/migrations/20241203_055_create_provider_documents_schema.sql`
- `supabase/migrations/20241203_056_create_providers_policies.sql`
- `supabase/migrations/20241203_057_create_providers_triggers.sql`
- `supabase/migrations/20241203_058_create_providers_views.sql`

🔄 **Comportement** :
Créer le schéma `bo_providers` avec isolation complète des données prestataires et intégration multi-portails.

Créer la table centrale `bo_providers.providers` avec les champs : company_name (VARCHAR NOT NULL), business_name (VARCHAR), description (TEXT), category_id (UUID FK vers bo_providers.provider_categories), subcategory_id (UUID FK nullable), status (VARCHAR avec ENUM provider_status), visibility (VARCHAR avec ENUM provider_visibility), featured (BOOLEAN DEFAULT false), logo_url (VARCHAR), cover_image_url (VARCHAR), website_url (VARCHAR), email (VARCHAR NOT NULL), phone (VARCHAR), address (JSONB), business_hours (JSONB), specialties (JSONB), certifications (JSONB), insurance_info (JSONB), tax_number (VARCHAR), registration_number (VARCHAR), founded_year (INTEGER), team_size (INTEGER), service_area (JSONB), languages (JSONB), social_media (JSONB), rating_average (DECIMAL(3,2) DEFAULT 0), rating_count (INTEGER DEFAULT 0), commission_rate (DECIMAL(5,2)), commission_type (VARCHAR avec ENUM commission_type), minimum_booking (DECIMAL(10,2)), cancellation_policy (TEXT), terms_conditions (TEXT), organization_id (UUID FK vers shared.organizations), created_by (UUID FK vers shared.user_profiles), plus les champs standard (id, created_at, updated_at).

Créer les ENUMs : `provider_status` (draft, pending_approval, active, suspended, archived, rejected), `provider_visibility` (public, private, restricted, client_only), `commission_type` (percentage, fixed_amount, tiered, custom), `contact_role` (admin, commercial, technical, financial, support), `service_pricing_type` (fixed, range, quote_only, hourly, daily), `document_type` (insurance, registration, certification, portfolio, contract_template, tax_document, other), `commission_status` (calculated, validated, invoiced, paid, disputed, cancelled).

Créer la table `bo_providers.provider_categories` avec : category_name (VARCHAR NOT NULL), category_slug (VARCHAR UNIQUE), description (TEXT), parent_category_id (UUID FK nullable vers bo_providers.provider_categories), icon_name (VARCHAR), color_code (VARCHAR), sort_order (INTEGER DEFAULT 0), is_active (BOOLEAN DEFAULT true), commission_default_rate (DECIMAL(5,2)), commission_default_type (VARCHAR avec ENUM commission_type), organization_id (UUID FK), plus champs standard.

Créer la table `bo_providers.provider_contacts` avec : provider_id (UUID FK vers bo_providers.providers), first_name (VARCHAR NOT NULL), last_name (VARCHAR NOT NULL), email (VARCHAR NOT NULL), phone (VARCHAR), role (VARCHAR avec ENUM contact_role), is_primary (BOOLEAN DEFAULT false), is_vendor_portal_user (BOOLEAN DEFAULT false), vendor_portal_user_id (UUID FK nullable vers shared.user_profiles), notes (TEXT), organization_id (UUID FK), plus champs standard.

Créer la table `bo_providers.provider_services` avec : provider_id (UUID FK vers bo_providers.providers), service_name (VARCHAR NOT NULL), service_description (TEXT), category_id (UUID FK vers bo_providers.provider_categories), pricing_type (VARCHAR avec ENUM service_pricing_type), base_price (DECIMAL(10,2)), price_range_min (DECIMAL(10,2)), price_range_max (DECIMAL(10,2)), price_unit (VARCHAR), duration_hours (DECIMAL(4,2)), setup_time_hours (DECIMAL(4,2)), breakdown_time_hours (DECIMAL(4,2)), max_guests (INTEGER), included_items (JSONB), additional_options (JSONB), requirements (JSONB), restrictions (JSONB), availability_calendar (JSONB), booking_lead_time_days (INTEGER), is_active (BOOLEAN DEFAULT true), organization_id (UUID FK), plus champs standard.

Créer la table `bo_providers.provider_documents` avec : provider_id (UUID FK vers bo_providers.providers), document_name (VARCHAR NOT NULL), document_type (VARCHAR avec ENUM document_type), file_url (VARCHAR NOT NULL), file_size (BIGINT), file_type (VARCHAR), upload_date (TIMESTAMPTZ DEFAULT NOW()), expiry_date (DATE), is_required (BOOLEAN DEFAULT false), is_validated (BOOLEAN DEFAULT false), validated_by (UUID FK nullable vers shared.user_profiles), validated_at (TIMESTAMPTZ), validation_notes (TEXT), visibility (VARCHAR avec ENUM provider_visibility), version_number (INTEGER DEFAULT 1), organization_id (UUID FK), uploaded_by (UUID FK vers shared.user_profiles), plus champs standard.

Créer la table `bo_providers.provider_commissions` avec : provider_id (UUID FK vers bo_providers.providers), event_id (UUID FK vers shared.events), service_id (UUID FK nullable vers bo_providers.provider_services), commission_amount (DECIMAL(10,2) NOT NULL), commission_rate (DECIMAL(5,2)), base_amount (DECIMAL(10,2) NOT NULL), commission_type (VARCHAR avec ENUM commission_type), status (VARCHAR avec ENUM commission_status), calculation_date (TIMESTAMPTZ DEFAULT NOW()), validation_date (TIMESTAMPTZ), validated_by (UUID FK nullable vers shared.user_profiles), invoice_id (UUID FK nullable vers shared.invoices), payment_date (TIMESTAMPTZ), notes (TEXT), organization_id (UUID FK), calculated_by (UUID FK vers shared.user_profiles), plus champs standard.

Créer la table `bo_providers.provider_reviews` avec : provider_id (UUID FK vers bo_providers.providers), event_id (UUID FK vers shared.events), client_id (UUID FK vers shared.clients), rating_overall (INTEGER CHECK (rating_overall >= 1 AND rating_overall <= 5)), rating_quality (INTEGER CHECK (rating_quality >= 1 AND rating_quality <= 5)), rating_communication (INTEGER CHECK (rating_communication >= 1 AND rating_communication <= 5)), rating_punctuality (INTEGER CHECK (rating_punctuality >= 1 AND rating_punctuality <= 5)), rating_value (INTEGER CHECK (rating_value >= 1 AND rating_value <= 5)), review_title (VARCHAR), review_text (TEXT), photos (JSONB), is_verified (BOOLEAN DEFAULT false), is_published (BOOLEAN DEFAULT false), is_featured (BOOLEAN DEFAULT false), response_text (TEXT), response_date (TIMESTAMPTZ), moderated_by (UUID FK nullable vers shared.user_profiles), moderated_at (TIMESTAMPTZ), organization_id (UUID FK), plus champs standard.

Créer la table `bo_providers.provider_availability` avec : provider_id (UUID FK vers bo_providers.providers), date (DATE NOT NULL), is_available (BOOLEAN DEFAULT true), availability_type (VARCHAR), notes (TEXT), created_by (UUID FK vers shared.user_profiles), organization_id (UUID FK), plus champs standard.

Créer la table `bo_providers.provider_activity_log` avec : provider_id (UUID FK vers bo_providers.providers), action_type (VARCHAR NOT NULL), action_description (TEXT), entity_type (VARCHAR), entity_id (UUID), old_values (JSONB), new_values (JSONB), ip_address (INET), user_agent (TEXT), organization_id (UUID FK), performed_by (UUID FK vers shared.user_profiles), plus champs standard.

Activer RLS sur toutes les tables avec politiques optimisées pour : rôles admin_providers (accès complet), provider_manager (lecture/écriture prestataires), event_planner (lecture prestataires actifs), accountant (lecture commissions), vendor_portal_user (lecture/écriture données propres), client_portal_user (lecture prestataires publics).

Créer les index optimisés : `idx_providers_category_status`, `idx_providers_organization_visibility`, `idx_provider_services_category`, `idx_provider_commissions_event`, `idx_provider_reviews_rating`, `idx_provider_contacts_email`, `idx_provider_documents_expiry`, `idx_provider_activity_log_date`.

Créer les triggers critiques pour : calcul automatique des moyennes de notation lors d'ajout/modification d'avis, mise à jour automatique des statuts de documents expirés, synchronisation des données avec Vendor Portal, génération automatique des logs d'activité, validation automatique des contraintes métier.

Créer les vues matérialisées pour optimisation : `vw_providers_extended` (prestataires avec détails complets), `vw_provider_statistics` (statistiques par prestataire), `vw_commission_summary` (résumé des commissions), `vw_provider_catalog` (catalogue pour Client Portal).

⚙️ **Interactions** :
- **Consomme** : Tables shared.events, shared.clients, shared.organizations, shared.user_profiles, shared.invoices
- **Expose** : Structure prestataires pour modules Événements, Contrats, Comptabilité, Vendor Portal, Client Portal
- **Partage** : Types `Provider`, `ProviderService`, `ProviderCommission` avec packages/types
- **Optimise** : Performance avec index spécialisés et vues matérialisées multi-portails

💡 **Tips Windsurf** :
- Utiliser Cascade Write Mode pour génération automatique des migrations complexes multi-portails
- Activer MCP Supabase pour création directe et validation des contraintes métier
- Référencer mémoire "Conventions Supabase Wedding Collection"
- Utiliser Claude 3.5 pour logique complexe des triggers de synchronisation multi-portails
- Optimiser les requêtes avec index composites pour les filtres fréquents

### Prompt 1.2 : Génération des Types TypeScript Prestataires Complets

🎯 **But** : Générer les types TypeScript complets et optimisés pour le module Gestion des Prestataires avec interfaces métier, enums de statuts, types utilitaires de commissions, schémas de validation Zod pour assurer la type-safety et la cohérence multi-portails

🧠 **Contexte** : Types métier partagés dans `packages/types` utilisés par toutes les applications du monorepo avec validation stricte des contraintes métier. Synchronisation automatique avec le schéma Supabase bo_providers et extension des types existants Événements et Clients.

🛠️ **Fichiers** :
- `packages/types/src/providers.ts`
- `packages/types/src/provider-categories.ts`
- `packages/types/src/provider-services.ts`
- `packages/types/src/provider-commissions.ts`
- `packages/types/src/provider-documents.ts`
- `packages/types/src/provider-reviews.ts`
- `packages/types/src/provider-validations.ts`
- `packages/types/src/database.ts` (mise à jour)
- `packages/types/src/index.ts` (export)

🔄 **Comportement** :
Générer l'interface `Provider` correspondant exactement à la table `bo_providers.providers` avec tous les champs typés selon les contraintes métier. Inclure les relations : `category?: ProviderCategory`, `subcategory?: ProviderCategory`, `contacts?: ProviderContact[]`, `services?: ProviderService[]`, `documents?: ProviderDocument[]`, `commissions?: ProviderCommission[]`, `reviews?: ProviderReview[]`, `availability?: ProviderAvailability[]`.

Créer les enums TypeScript correspondant aux enums SQL avec validation stricte : `ProviderStatus`, `ProviderVisibility`, `CommissionType`, `ContactRole`, `ServicePricingType`, `DocumentType`, `CommissionStatus`.

Générer les interfaces pour toutes les entités métier : `ProviderCategory`, `ProviderContact`, `ProviderService`, `ProviderDocument`, `ProviderCommission`, `ProviderReview`, `ProviderAvailability`, `ProviderActivityLog`.

Créer les types utilitaires métier : `ProviderCreate` (Omit<Provider, 'id' | 'created_at' | 'updated_at'>), `ProviderUpdate` (Partial<ProviderCreate>), `ProviderWithDetails` (avec toutes les relations chargées), `ProviderListItem` (version allégée pour les listes), `ProviderCatalogItem` (version publique pour Client Portal), `ProviderDashboard` (métriques et statuts).

Créer les types de commissions : `CommissionCalculation` (données de calcul), `CommissionRule` (règle de commission), `CommissionSummary` (résumé par période), `CommissionValidation` (validation de commission), `CommissionReport` (rapport financier).

Générer les types de services : `ServiceConfiguration` (configuration du service), `ServicePricing` (tarification détaillée), `ServiceAvailability` (disponibilité du service), `ServiceBooking` (réservation de service), `ServiceQuote` (devis de service).

Créer les types de recherche et filtrage : `ProviderFilters` (category_id?, status?, visibility?, location?, rating_min?, services?, availability_date?), `ProviderSearchResult`, `ProviderListOptions`, `ProviderSortOptions`.

Créer les types pour les formulaires : `ProviderFormData`, `ProviderServiceFormData`, `ProviderContactFormData`, `ProviderDocumentFormData`, `CommissionValidationFormData`.

Créer les schémas de validation Zod avec contraintes métier : `ProviderSchema` (validation informations entreprise, contact, métier), `ProviderServiceSchema` (validation tarifs, disponibilités), `ProviderCommissionSchema` (validation calculs, taux), `ProviderDocumentSchema` (validation types, expirations).

Ajouter les types pour les APIs multi-portails : `ProviderApiResponse`, `ProviderListResponse`, `ProviderStatsResponse`, `CommissionCalculationRequest`, `ProviderValidationResponse`, `VendorPortalProviderData`, `ClientPortalProviderData`.

Créer les types de performance et analytics : `ProviderMetrics` (métriques de performance), `ProviderAnalytics` (analyses détaillées), `CommissionAnalytics` (analyses financières), `ReviewAnalytics` (analyses de satisfaction), `ProviderComparison` (comparaison de prestataires).

Créer les types multi-portails : `VendorPortalProfile` (profil Vendor Portal), `ClientPortalListing` (listing Client Portal), `BackofficeProviderView` (vue Backoffice), `PortalSyncData` (données de synchronisation).

⚙️ **Interactions** :
- **Consomme** : Types Event, Client, Organization, UserProfile du schéma Supabase
- **Expose** : Types métier vers toutes les applications du monorepo
- **Partage** : Types communs avec modules Événements, Contrats, Comptabilité
- **Valide** : Contraintes métier avec TypeScript strict et Zod

💡 **Tips Windsurf** :
- Utiliser Supercomplete pour cohérence avec patterns TypeScript métier
- Activer génération automatique depuis schéma Supabase bo_providers
- Valider types avec compilation TypeScript stricte et contraintes métier
- Synchroniser avec mémoire "Types Wedding Collection"
- Utiliser Claude 3.5 pour logique complexe des types de commissions

### Prompt 1.3 : Architecture des Services Métier et Edge Functions

🎯 **But** : Créer l'architecture complète des services métier pour le module Gestion des Prestataires avec Edge Functions Supabase, services de calcul de commissions, synchronisation multi-portails, gestion des workflows, et couches service/repository avec validation métier

🧠 **Contexte** : Services métier dans `apps/backoffice/src/lib/services` utilisant Supabase client, Edge Functions pour calculs complexes et synchronisation, validation Zod renforcée, et gestion d'erreurs spécialisée pour opérations multi-portails.

🛠️ **Fichiers** :
- `supabase/functions/calculate-provider-commission/index.ts`
- `supabase/functions/sync-vendor-portal-data/index.ts`
- `supabase/functions/validate-provider-documents/index.ts`
- `supabase/functions/generate-provider-reports/index.ts`
- `supabase/functions/update-provider-ratings/index.ts`
- `apps/backoffice/src/lib/services/providers-service.ts`
- `apps/backoffice/src/lib/services/provider-commissions-service.ts`
- `apps/backoffice/src/lib/services/provider-documents-service.ts`
- `apps/backoffice/src/lib/services/provider-sync-service.ts`
- `apps/backoffice/src/lib/repositories/providers-repository.ts`
- `apps/backoffice/src/lib/validators/providers-validators.ts`
- `apps/backoffice/src/lib/errors/providers-errors.ts`

🔄 **Comportement** :
Créer les Edge Functions Supabase critiques : `calculate-provider-commission` pour calcul automatique des commissions basé sur les événements avec règles complexes, `sync-vendor-portal-data` pour synchronisation bidirectionnelle avec Vendor Portal, `validate-provider-documents` pour validation automatique des documents avec alertes d'expiration, `generate-provider-reports` pour génération de rapports financiers et performance, `update-provider-ratings` pour mise à jour automatique des moyennes de notation.

Créer `ProvidersRepository` avec méthodes optimisées : `findProviders(filters?, pagination?)`, `findProviderById(id)`, `findProvidersByCategory(categoryId)`, `findProvidersByLocation(location)`, `findProvidersByAvailability(date)`, `createProvider(data)`, `updateProvider(id, data)`, `deleteProvider(id)`, `updateProviderStatus(id, status)`, `searchProviders(query, filters)`. Implémenter la logique de requêtes Supabase avec gestion des relations complexes et filtres métier.

Créer `ProvidersService` avec logique métier : `createProviderProfile(data)`, `updateProviderProfile(id, data)`, `validateProviderData(data)`, `approveProvider(id)`, `suspendProvider(id, reason)`, `archiveProvider(id)`, `searchProvidersForEvent(eventData)`, `getProviderRecommendations(criteria)`, `calculateProviderScore(id)`. Intégrer validation business et gestion des workflows d'approbation.

Créer `ProviderCommissionsService` avec : `calculateCommission(eventId, providerId, amount)`, `validateCommission(commissionId)`, `approveCommission(commissionId)`, `generateCommissionInvoice(commissionId)`, `getCommissionSummary(providerId, period)`, `processCommissionPayment(commissionId)`, `disputeCommission(commissionId, reason)`. Gérer les règles de commission complexes et workflows financiers.

Créer `ProviderDocumentsService` avec : `uploadDocument(providerId, file, type)`, `validateDocument(documentId)`, `checkDocumentExpiry()`, `generateExpiryAlerts()`, `archiveDocument(documentId)`, `getDocumentHistory(providerId)`, `validateRequiredDocuments(providerId)`. Gérer le cycle de vie des documents avec validation automatique.

Créer `ProviderSyncService` avec : `syncWithVendorPortal(providerId)`, `validateVendorPortalChanges(changes)`, `approveVendorPortalChanges(changeId)`, `rejectVendorPortalChanges(changeId, reason)`, `syncToClientPortal(providerId)`, `updatePortalVisibility(providerId, visibility)`. Gérer la synchronisation multi-portails avec validation.

Créer les validateurs Zod avec contraintes métier : `createProviderSchema` (validation informations entreprise, contact, métier), `updateProviderSchema`, `providerServiceSchema` (validation tarifs, disponibilités), `commissionCalculationSchema` (validation calculs, règles), `documentUploadSchema` (validation types, formats).

Implémenter la gestion d'erreurs spécialisée : `ProviderNotFoundError`, `InvalidCommissionRuleError`, `DocumentValidationError`, `PortalSyncError`, `ProviderApprovalError`, `CommissionCalculationError` avec codes d'erreur standardisés et messages métier.

Créer les services de performance : `ProviderAnalyticsService` pour calcul des métriques de performance, `ProviderRecommendationService` pour suggestions intelligentes, `ProviderComparisonService` pour comparaisons détaillées, `ProviderReportingService` pour génération de rapports.

⚙️ **Interactions** :
- **Consomme** : Types packages/types, client Supabase, données Événements et Clients
- **Expose** : Services métier vers controllers API et composants frontend
- **Émet** : Événements provider_created, commission_calculated, document_validated, portal_synced
- **Intègre** : Modules Événements, Contrats, Comptabilité, Vendor Portal, Client Portal

💡 **Tips Windsurf** :
- Utiliser Cascade Chat Mode pour logique métier complexe des Edge Functions
- Référencer patterns de services métier existants
- Intégrer validation Zod avec contraintes métier strictes
- Utiliser MCP Supabase pour déploiement direct des Edge Functions
- Tester logique de commissions avec scénarios réalistes

### Prompt 1.4 : Configuration des Hooks et Contextes Métier

🎯 **But** : Développer l'architecture complète des hooks personnalisés et contextes React pour le module Gestion des Prestataires avec gestion d'état métier optimisée, cache intelligent, synchronisation multi-portails, et patterns de performance

🧠 **Contexte** : Hooks et contextes métier dans `apps/backoffice/src/hooks` et `apps/backoffice/src/contexts` utilisant React Query pour le cache, Supabase Realtime pour synchronisation, et patterns de gestion d'état optimisés pour les données métier complexes.

🛠️ **Fichiers** :
- `apps/backoffice/src/contexts/ProvidersContext.tsx`
- `apps/backoffice/src/hooks/useProviders.ts`
- `apps/backoffice/src/hooks/useProviderCommissions.ts`
- `apps/backoffice/src/hooks/useProviderDocuments.ts`
- `apps/backoffice/src/hooks/useProviderSearch.ts`
- `apps/backoffice/src/hooks/useProviderSync.ts`
- `apps/backoffice/src/hooks/useProviderAnalytics.ts`
- `apps/backoffice/src/hooks/useProviderValidation.ts`
- `apps/backoffice/src/hooks/useProviderRecommendations.ts`

🔄 **Comportement** :
Créer `ProvidersContext` avec état global métier : prestataires actifs, filtres appliqués, sélections multiples, cache des catégories, préférences de recherche, paramètres de synchronisation. Fournir actions : selectProvider, updateFilters, refreshProviderData, syncPortalData, validateProvider.

Développer `useProviders` avec : `data` (liste des prestataires), `isLoading`, `error`, `refetch`, `hasNextPage`, `fetchNextPage` pour pagination infinie. Intégrer filtrage avancé (catégorie, statut, localisation, notation, disponibilité), tri multiple, recherche textuelle. Implémenter cache intelligent avec invalidation basée sur les événements métier.

Créer `useProviderCommissions(providerId?)` avec : `commissions` (commissions du prestataire), `calculateCommission`, `validateCommission`, `approveCommission`, `generateInvoice`, `getCommissionSummary`. Gérer les mises à jour temps réel des statuts de commissions et optimistic updates sécurisées.

Implémenter `useProviderDocuments(providerId)` avec : `documents`, `uploadDocument`, `validateDocument`, `checkExpiry`, `generateAlerts`, `archiveDocument`. Optimiser les mises à jour avec validation temps réel et cache des documents fréquents.

Développer `useProviderSearch(query?, filters?)` avec : `results`, `search`, `saveSearch`, `loadSavedSearches`, `exportResults`, `getRecommendations`. Intégrer recherche intelligente et gestion des filtres complexes.

Créer `useProviderSync(providerId?)` avec : `syncStatus`, `syncWithVendorPortal`, `validateChanges`, `approveChanges`, `rejectChanges`, `getSyncHistory`. Gérer synchronisation multi-portails et validation des modifications.

Implémenter `useProviderAnalytics(providerId?, period?)` avec : `metrics`, `performance`, `commissions`, `reviews`, `trends`, `generateReport`. Optimiser les calculs avec memoization et cache des métriques.

Développer `useProviderValidation(providerId?)` avec : `validationStatus`, `validateProvider`, `approveProvider`, `rejectProvider`, `getValidationHistory`, `checkRequirements`. Gérer workflows de validation et approbation.

Créer `useProviderRecommendations(criteria?)` avec : `recommendations`, `getRecommendations`, `saveRecommendation`, `rateRecommendation`, `getRecommendationHistory`. Intégrer logique de recommandation intelligente.

Implémenter patterns d'optimisation métier : memoization des calculs de commissions, lazy loading des données non critiques, prefetching des prestataires populaires, cleanup automatique des données obsolètes, validation de cohérence continue.

⚙️ **Interactions** :
- **Consomme** : Services métier, types TypeScript, client Supabase temps réel
- **Expose** : Hooks métier vers composants React, état global via contexte
- **Intègre** : React Query pour cache, Supabase Realtime, synchronisation multi-portails
- **Optimise** : Performance avec memoization et gestion mémoire intelligente

💡 **Tips Windsurf** :
- Utiliser Supercomplete pour patterns React hooks métier
- Activer mémoire "React Patterns Wedding Collection"
- Référencer hooks existants avec /Reference Open Editors
- Optimiser performance avec React DevTools Profiler pour données complexes
- Tester hooks avec React Testing Library et scénarios multi-portails

---

## Section 2 : Fonctionnalités Principales


### Prompt 2.1 : Interface de Gestion des Prestataires avec Recherche Avancée

🎯 **But** : Développer l'interface complète de gestion des prestataires avec tableau de bord principal, recherche avancée multi-critères, filtrage intelligent, gestion des statuts, actions en lot, et intégration multi-portails

🧠 **Contexte** : Interface principale du module dans `apps/backoffice/src/app/providers` utilisant ShadCN UI, React Hook Form, et patterns de performance pour gestion de grandes listes de prestataires avec filtres complexes et actions métier.

🛠️ **Fichiers** :
- `apps/backoffice/src/app/providers/page.tsx`
- `apps/backoffice/src/app/providers/components/ProvidersTable.tsx`
- `apps/backoffice/src/app/providers/components/ProviderFilters.tsx`
- `apps/backoffice/src/app/providers/components/ProviderSearch.tsx`
- `apps/backoffice/src/app/providers/components/ProviderActions.tsx`
- `apps/backoffice/src/app/providers/components/ProviderStatusBadge.tsx`
- `apps/backoffice/src/app/providers/components/ProviderQuickView.tsx`
- `apps/backoffice/src/app/providers/components/BulkActions.tsx`

🔄 **Comportement** :
Créer la page principale `providers/page.tsx` avec layout responsive, header avec statistiques (total prestataires, actifs, en attente, commissions du mois), barre de recherche globale, filtres avancés, bouton d'ajout de prestataire, et tableau principal avec pagination.

Développer `ProvidersTable` avec colonnes : logo/nom entreprise, catégorie, statut avec badge coloré, notation moyenne avec étoiles, localisation, dernière activité, commissions générées, actions (voir, modifier, suspendre, archiver). Implémenter tri multi-colonnes, sélection multiple, actions en lot, et lazy loading pour performance.

Créer `ProviderFilters` avec filtres : catégorie (dropdown hiérarchique), statut (multi-select), localisation (autocomplete avec géolocalisation), notation minimum (slider), date d'inscription (date range), commission générée (range), disponibilité (date picker), visibilité portail. Sauvegarder les filtres fréquents et permettre partage des vues filtrées.

Implémenter `ProviderSearch` avec recherche intelligente : nom entreprise, description, services, tags, contact. Intégrer suggestions automatiques, historique des recherches, recherche sauvegardée, et export des résultats. Optimiser avec debouncing et cache des résultats.

Développer `ProviderActions` avec menu contextuel : voir détails, modifier profil, gérer services, gérer documents, voir commissions, synchroniser portail, approuver/rejeter, suspendre/réactiver, archiver, dupliquer, exporter données. Gérer permissions selon rôle utilisateur.

Créer `ProviderStatusBadge` avec statuts colorés : draft (gris), pending_approval (orange), active (vert), suspended (rouge), archived (gris foncé), rejected (rouge foncé). Inclure tooltips explicatifs et actions rapides selon statut.

Implémenter `ProviderQuickView` avec modal de prévisualisation : informations essentielles, services principaux, dernières commissions, avis récents, documents expirés, actions rapides. Optimiser chargement avec données mises en cache.

Développer `BulkActions` pour sélection multiple : approuver en lot, changer statut, exporter sélection, envoyer notifications, synchroniser portails, archiver, supprimer. Inclure confirmation et progress tracking pour opérations longues.

Intégrer patterns de performance : virtualisation pour grandes listes, pagination intelligente, prefetching des données fréquentes, memoization des composants coûteux, lazy loading des images et documents.

⚙️ **Interactions** :
- **Consomme** : Hooks useProviders, useProviderSearch, services métier
- **Intègre** : Modules Événements (associations), Contrats (génération), Comptabilité (commissions)
- **Synchronise** : Vendor Portal (modifications), Client Portal (visibilité)
- **Notifie** : Changements de statut, validations, synchronisations

💡 **Tips Windsurf** :
- Utiliser Cascade Write Mode pour génération complète des composants liés
- Référencer patterns UI existants avec /Reference Open Editors
- Optimiser performance avec React.memo et useMemo pour listes importantes
- Intégrer ShadCN UI avec thème Wedding Collection cohérent
- Tester responsivité sur différentes tailles d'écran

### Prompt 2.2 : Formulaire de Gestion Prestataire Complet

🎯 **But** : Créer le formulaire complet de création et modification des prestataires avec validation métier avancée, gestion des médias, configuration des services, gestion des contacts, et workflow d'approbation

🧠 **Contexte** : Formulaire complexe multi-étapes dans `apps/backoffice/src/app/providers/[id]` utilisant React Hook Form, validation Zod, upload de fichiers Supabase Storage, et patterns de UX optimisés pour saisie de données métier complexes.

🛠️ **Fichiers** :
- `apps/backoffice/src/app/providers/[id]/page.tsx`
- `apps/backoffice/src/app/providers/[id]/components/ProviderForm.tsx`
- `apps/backoffice/src/app/providers/[id]/components/BasicInfoStep.tsx`
- `apps/backoffice/src/app/providers/[id]/components/ContactsStep.tsx`
- `apps/backoffice/src/app/providers/[id]/components/ServicesStep.tsx`
- `apps/backoffice/src/app/providers/[id]/components/DocumentsStep.tsx`
- `apps/backoffice/src/app/providers/[id]/components/MediaStep.tsx`
- `apps/backoffice/src/app/providers/[id]/components/CommissionStep.tsx`
- `apps/backoffice/src/app/providers/[id]/components/ReviewStep.tsx`

🔄 **Comportement** :
Créer la page `providers/[id]/page.tsx` avec détection mode création/modification, breadcrumb navigation, header avec statut du prestataire, actions contextuelles (sauvegarder, approuver, rejeter, prévisualiser), et indicateur de progression multi-étapes.

Développer `ProviderForm` avec stepper horizontal : Informations de base, Contacts, Services, Documents, Médias, Commissions, Révision. Implémenter navigation entre étapes avec validation progressive, sauvegarde automatique, et gestion des erreurs par étape.

Créer `BasicInfoStep` avec champs : nom entreprise (requis), nom commercial, description riche (éditeur WYSIWYG), catégorie principale (dropdown), sous-catégorie (conditionnel), site web (validation URL), email principal (validation), téléphone (format international), adresse complète (autocomplete), horaires d'ouverture (widget horaires), spécialités (tags), certifications (liste), informations assurance (upload), numéro SIRET/TVA, année de création, taille équipe, zone de service (carte interactive), langues parlées (multi-select), réseaux sociaux (liens).

Implémenter `ContactsStep` avec gestion dynamique des contacts : prénom/nom (requis), email (unique), téléphone, rôle (admin, commercial, technique, financier), contact principal (radio), accès Vendor Portal (checkbox avec génération invitation), notes. Permettre ajout/suppression de contacts avec validation des rôles obligatoires.

Développer `ServicesStep` avec configuration des services : nom service (requis), description détaillée, catégorie de service, type de tarification (fixe, fourchette, sur devis, horaire, journalier), prix de base, fourchette min/max, unité de prix, durée prestation, temps installation/démontage, nombre maximum d'invités, éléments inclus (liste), options supplémentaires (avec tarifs), exigences techniques, restrictions, délai de réservation, disponibilité (calendrier). Permettre duplication et templates de services.

Créer `DocumentsStep` avec upload et gestion : type de document (assurance, Kbis, certification, portfolio, contrat type), nom du document, fichier (drag & drop), date d'expiration (avec alertes), document obligatoire (checkbox), visibilité (interne, prestataire, client), notes de validation. Prévisualisation des documents et versioning.

Implémenter `MediaStep` avec gestion des médias : logo entreprise (carré, formats acceptés), image de couverture (bannière), galerie photos (portfolio), vidéos de présentation. Optimisation automatique des images, recadrage intelligent, et génération de thumbnails.

Développer `CommissionStep` avec configuration : taux de commission (pourcentage), type de commission (pourcentage, montant fixe, échelonné), montant minimum de réservation, conditions spéciales, politique d'annulation, termes et conditions. Calculateur de commission en temps réel avec exemples.

Créer `ReviewStep` avec récapitulatif complet : résumé des informations saisies, validation des champs obligatoires, aperçu du profil public, actions finales (sauvegarder brouillon, soumettre pour approbation, publier directement selon permissions).

Intégrer validation Zod progressive avec messages d'erreur contextuels, sauvegarde automatique toutes les 30 secondes, gestion des conflits de modification simultanée, et optimistic updates pour UX fluide.

⚙️ **Interactions** :
- **Consomme** : Hooks useProviders, services upload, validation Zod
- **Intègre** : Supabase Storage (médias), géolocalisation (adresses), calendrier (disponibilités)
- **Synchronise** : Vendor Portal (profil), Client Portal (visibilité)
- **Valide** : Contraintes métier, unicité email, formats documents

💡 **Tips Windsurf** :
- Utiliser Cascade Chat Mode pour logique complexe de validation multi-étapes
- Référencer patterns de formulaires existants dans l'ERP
- Optimiser UX avec React Hook Form et validation temps réel
- Intégrer upload progressif avec Supabase Storage
- Tester workflows complets de création/modification

### Prompt 2.3 : Système de Gestion des Commissions Avancé

🎯 **But** : Développer le système complet de gestion des commissions avec calcul automatique, validation workflow, facturation intégrée, reporting financier, et tableau de bord analytique

🧠 **Contexte** : Module financier critique dans `apps/backoffice/src/app/providers/commissions` intégré avec module Comptabilité, utilisant Edge Functions pour calculs complexes, et patterns de validation financière stricte.

🛠️ **Fichiers** :
- `apps/backoffice/src/app/providers/commissions/page.tsx`
- `apps/backoffice/src/app/providers/commissions/components/CommissionsDashboard.tsx`
- `apps/backoffice/src/app/providers/commissions/components/CommissionsTable.tsx`
- `apps/backoffice/src/app/providers/commissions/components/CommissionCalculator.tsx`
- `apps/backoffice/src/app/providers/commissions/components/CommissionValidation.tsx`
- `apps/backoffice/src/app/providers/commissions/components/CommissionReports.tsx`
- `apps/backoffice/src/app/providers/commissions/components/CommissionRules.tsx`
- `apps/backoffice/src/app/providers/commissions/[id]/page.tsx`

🔄 **Comportement** :
Créer la page principale `commissions/page.tsx` avec dashboard financier : métriques du mois (commissions calculées, validées, facturées, payées), graphiques de tendances, top prestataires par commission, alertes de validation en attente, raccourcis vers actions fréquentes.

Développer `CommissionsDashboard` avec widgets : total commissions période, évolution mensuelle (graphique), répartition par statut (donut), top 10 prestataires (tableau), commissions en attente de validation (liste), prochaines échéances de paiement, indicateurs de performance (taux de validation, délai moyen).

Implémenter `CommissionsTable` avec colonnes : prestataire, événement, service, montant de base, taux commission, montant commission, statut avec badge, date calcul, date validation, actions (valider, facturer, disputer). Filtres : période, prestataire, statut, montant, événement. Export Excel/PDF avec détails.

Créer `CommissionCalculator` avec interface de calcul : sélection événement, prestataire, service, montant de base, application automatique des règles de commission, prévisualisation du calcul, validation des données, sauvegarde du calcul. Gestion des cas spéciaux : remises, suppléments, commissions échelonnées.

Développer `CommissionValidation` avec workflow : liste des commissions à valider, détails de chaque commission (événement, prestataire, calcul), historique des modifications, commentaires de validation, actions (approuver, rejeter, demander modification), notifications automatiques aux parties prenantes.

Implémenter `CommissionReports` avec rapports : synthèse mensuelle par prestataire, analyse des tendances, comparaison périodes, rentabilité par catégorie, détection d'anomalies, export comptable (FEC), rapports personnalisés avec filtres avancés.

Créer `CommissionRules` avec configuration : règles par catégorie de prestataire, taux par défaut, conditions spéciales, seuils de montants, règles d'échelonnement, exceptions par prestataire, validation des règles, historique des modifications.

Développer la page détail `commissions/[id]/page.tsx` avec : informations complètes de la commission, historique des modifications, documents associés, communications liées, actions disponibles selon statut, timeline du processus.

Intégrer calculs automatiques : déclenchement post-événement, application des règles configurées, validation des montants, génération des notifications, mise à jour des statuts, synchronisation avec module Comptabilité.

⚙️ **Interactions** :
- **Consomme** : Données Événements, Prestataires, règles de commission
- **Intègre** : Module Comptabilité (facturation), Module Contrats (conditions)
- **Génère** : Factures, écritures comptables, rapports financiers
- **Notifie** : Prestataires (Vendor Portal), équipes internes, comptabilité

💡 **Tips Windsurf** :
- Utiliser Edge Functions pour calculs financiers complexes et sécurisés
- Référencer patterns financiers du module Comptabilité
- Implémenter validation stricte avec contraintes métier
- Optimiser performance avec cache des règles de commission
- Tester scénarios de calcul avec données réalistes

### Prompt 2.4 : Interface de Synchronisation Multi-Portails

🎯 **But** : Créer l'interface complète de synchronisation et validation des données entre Backoffice, Vendor Portal et Client Portal avec workflow d'approbation, gestion des conflits, et monitoring temps réel

🧠 **Contexte** : Interface de synchronisation dans `apps/backoffice/src/app/providers/sync` gérant les échanges bidirectionnels avec les portails externes, validation des modifications, et résolution des conflits de données.

🛠️ **Fichiers** :
- `apps/backoffice/src/app/providers/sync/page.tsx`
- `apps/backoffice/src/app/providers/sync/components/SyncDashboard.tsx`
- `apps/backoffice/src/app/providers/sync/components/PendingChanges.tsx`
- `apps/backoffice/src/app/providers/sync/components/SyncHistory.tsx`
- `apps/backoffice/src/app/providers/sync/components/ConflictResolution.tsx`
- `apps/backoffice/src/app/providers/sync/components/PortalVisibility.tsx`
- `apps/backoffice/src/app/providers/sync/components/SyncSettings.tsx`
- `apps/backoffice/src/app/providers/sync/[providerId]/page.tsx`

🔄 **Comportement** :
Créer la page principale `sync/page.tsx` avec vue d'ensemble : statut de synchronisation global, modifications en attente par portail, conflits à résoudre, dernières synchronisations, alertes de validation, statistiques de performance.

Développer `SyncDashboard` avec métriques : nombre de prestataires synchronisés, modifications en attente (Vendor Portal), conflits détectés, taux de validation automatique, délai moyen de traitement, statut des portails (en ligne/hors ligne).

Implémenter `PendingChanges` avec liste des modifications : prestataire concerné, type de modification (profil, services, documents), portail source, date de soumission, priorité, statut de validation, actions (approuver, rejeter, demander clarification). Filtres par portail, type, date, priorité.

Créer `SyncHistory` avec historique complet : toutes les synchronisations effectuées, succès/échecs, détails des modifications appliquées, utilisateurs impliqués, temps de traitement, logs détaillés. Recherche et filtrage avancés.

Développer `ConflictResolution` avec gestion des conflits : détection automatique des conflits de données, comparaison côte à côte des versions, outils de fusion intelligente, résolution manuelle guidée, validation des résolutions, notification des parties prenantes.

Implémenter `PortalVisibility` avec contrôle de visibilité : configuration par prestataire de la visibilité sur Client Portal, gestion des données publiques/privées, prévisualisation du profil public, contrôle des services affichés, gestion des médias visibles.

Créer `SyncSettings` avec configuration : règles de synchronisation automatique, seuils de validation, notifications par type de modification, paramètres de résolution de conflits, planification des synchronisations, configuration des webhooks.

Développer la page détail `sync/[providerId]/page.tsx` avec : historique complet des synchronisations du prestataire, modifications en cours, conflits spécifiques, configuration de synchronisation, actions manuelles disponibles.

Intégrer monitoring temps réel : WebSocket pour mises à jour instantanées, notifications push pour modifications urgentes, indicateurs de statut en temps réel, alertes automatiques pour échecs de synchronisation.

⚙️ **Interactions** :
- **Synchronise** : Vendor Portal (bidirectionnel), Client Portal (unidirectionnel)
- **Valide** : Modifications selon règles métier, contraintes de cohérence
- **Notifie** : Prestataires, équipes internes, administrateurs portails
- **Intègre** : Système de notifications, logs d'audit, gestion des erreurs

💡 **Tips Windsurf** :
- Utiliser Supabase Realtime pour synchronisation temps réel
- Implémenter patterns de résolution de conflits robustes
- Optimiser UX avec indicateurs de statut clairs
- Tester scénarios de synchronisation complexes
- Référencer patterns de validation existants

---

## Section 3 : Fonctionnalités Secondaires

### Prompt 3.1 : Tableaux de Bord et Analytics Prestataires

🎯 **But** : Développer les tableaux de bord analytiques complets pour le module Gestion des Prestataires avec métriques de performance, analyses prédictives, comparaisons, et reporting avancé

🧠 **Contexte** : Interface analytique dans `apps/backoffice/src/app/providers/analytics` utilisant bibliothèques de visualisation (Recharts, Chart.js), calculs de métriques complexes, et patterns de performance pour grandes quantités de données.

🛠️ **Fichiers** :
- `apps/backoffice/src/app/providers/analytics/page.tsx`
- `apps/backoffice/src/app/providers/analytics/components/PerformanceDashboard.tsx`
- `apps/backoffice/src/app/providers/analytics/components/CommissionAnalytics.tsx`
- `apps/backoffice/src/app/providers/analytics/components/ProviderComparison.tsx`
- `apps/backoffice/src/app/providers/analytics/components/TrendAnalysis.tsx`
- `apps/backoffice/src/app/providers/analytics/components/SatisfactionMetrics.tsx`
- `apps/backoffice/src/app/providers/analytics/components/RevenueAnalysis.tsx`
- `apps/backoffice/src/app/providers/analytics/components/CustomReports.tsx`

🔄 **Comportement** :
Créer la page principale `analytics/page.tsx` avec dashboard exécutif : KPIs globaux (nombre prestataires actifs, commissions générées, satisfaction moyenne, taux de conversion), graphiques de tendances, top performers, alertes de performance, raccourcis vers analyses détaillées.

Développer `PerformanceDashboard` avec métriques clés : taux de conversion par prestataire, délai moyen de réponse, taux de satisfaction client, nombre d'événements réalisés, évolution des performances, comparaison avec moyennes sectorielles, identification des prestataires en difficulté.

Implémenter `CommissionAnalytics` avec analyses financières : évolution des commissions par période, répartition par catégorie de prestataire, top générateurs de commissions, analyse de rentabilité, prévisions basées sur tendances, détection d'anomalies financières.

Créer `ProviderComparison` avec outils de comparaison : sélection multiple de prestataires, comparaison sur critères multiples (performance, satisfaction, commissions, disponibilité), visualisations radar, tableaux comparatifs, export des analyses.

Développer `TrendAnalysis` avec analyses prédictives : identification des tendances de marché, prévisions de demande par catégorie, analyse saisonnière, détection de patterns de comportement, recommandations d'optimisation, alertes de changements significatifs.

Implémenter `SatisfactionMetrics` avec analyses de satisfaction : évolution des notes par prestataire, analyse des commentaires clients, identification des points d'amélioration, corrélation satisfaction/performance, benchmarking sectoriel.

Créer `RevenueAnalysis` avec analyses de revenus : contribution de chaque prestataire au chiffre d'affaires, analyse de la rentabilité par catégorie, impact des commissions sur la marge, optimisation des taux de commission, projections financières.

Développer `CustomReports` avec générateur de rapports : sélection de métriques personnalisées, filtres avancés, planification automatique, export multi-formats (PDF, Excel, CSV), partage sécurisé, historique des rapports générés.

Intégrer visualisations interactives : graphiques dynamiques avec drill-down, cartes de chaleur pour performance géographique, timelines interactives, dashboards personnalisables par utilisateur.

⚙️ **Interactions** :
- **Consomme** : Données Prestataires, Événements, Commissions, Avis clients
- **Calcule** : Métriques de performance, KPIs, tendances, prévisions
- **Exporte** : Rapports, analyses, visualisations
- **Intègre** : Modules Événements, Comptabilité, Suivi des Mariages

💡 **Tips Windsurf** :
- Utiliser bibliothèques de visualisation performantes (Recharts, D3.js)
- Optimiser calculs avec Web Workers pour métriques complexes
- Implémenter cache intelligent pour données analytiques
- Référencer patterns de dashboard existants
- Tester performance avec grandes quantités de données

### Prompt 3.2 : Gestion Avancée des Documents et Médias

🎯 **But** : Créer le système complet de gestion documentaire et média pour les prestataires avec versioning, validation automatique, alertes d'expiration, et organisation intelligente

🧠 **Contexte** : Module documentaire dans `apps/backoffice/src/app/providers/documents` intégré avec Supabase Storage, gestion des permissions, et workflows de validation automatique.

🛠️ **Fichiers** :
- `apps/backoffice/src/app/providers/documents/page.tsx`
- `apps/backoffice/src/app/providers/documents/components/DocumentLibrary.tsx`
- `apps/backoffice/src/app/providers/documents/components/DocumentUpload.tsx`
- `apps/backoffice/src/app/providers/documents/components/DocumentValidation.tsx`
- `apps/backoffice/src/app/providers/documents/components/ExpiryAlerts.tsx`
- `apps/backoffice/src/app/providers/documents/components/MediaGallery.tsx`
- `apps/backoffice/src/app/providers/documents/components/DocumentVersioning.tsx`
- `apps/backoffice/src/app/providers/documents/[id]/page.tsx`

🔄 **Comportement** :
Créer la page principale `documents/page.tsx` avec vue d'ensemble : statistiques des documents (total, validés, expirés, en attente), alertes d'expiration par priorité, documents récemment ajoutés, actions rapides (validation en lot, génération d'alertes).

Développer `DocumentLibrary` avec organisation intelligente : arborescence par prestataire et type de document, recherche avancée (nom, type, contenu OCR), filtres multiples (statut, expiration, validation), vue liste/grille, tri personnalisable, sélection multiple pour actions en lot.

Implémenter `DocumentUpload` avec interface avancée : drag & drop multiple, prévisualisation instantanée, détection automatique du type, validation des formats, compression automatique, upload progressif avec reprise, métadonnées automatiques (taille, type, date).

Créer `DocumentValidation` avec workflow : queue de validation, prévisualisation des documents, outils d'annotation, validation par lot, historique des validations, notifications automatiques, intégration avec OCR pour extraction de données.

Développer `ExpiryAlerts` avec système d'alertes : calendrier des expirations, alertes automatiques (30, 15, 7 jours), notifications par email/SMS, suivi des renouvellements, escalade automatique, tableau de bord des urgences.

Implémenter `MediaGallery` avec gestion des médias : galerie photos/vidéos par prestataire, organisation par albums, outils d'édition basiques (recadrage, filtres), génération de thumbnails, optimisation automatique, intégration avec profils publics.

Créer `DocumentVersioning` avec gestion des versions : historique complet des versions, comparaison visuelle, restauration de versions antérieures, commentaires par version, approbation des nouvelles versions, archivage automatique.

Développer la page détail `documents/[id]/page.tsx` avec : prévisualisation complète, métadonnées détaillées, historique des modifications, commentaires et annotations, actions contextuelles, partage sécurisé.

Intégrer fonctionnalités avancées : OCR pour extraction de texte, reconnaissance automatique de types de documents, validation automatique par IA, génération de rapports de conformité, synchronisation avec systèmes externes.

⚙️ **Interactions** :
- **Stocke** : Supabase Storage avec organisation hiérarchique
- **Valide** : Contraintes métier, formats autorisés, tailles limites
- **Notifie** : Alertes d'expiration, validations requises, nouveaux uploads
- **Intègre** : Profils prestataires, Vendor Portal, Client Portal

💡 **Tips Windsurf** :
- Utiliser Supabase Storage avec politiques RLS granulaires
- Implémenter upload progressif avec gestion d'erreurs robuste
- Optimiser performance avec lazy loading et compression
- Intégrer OCR avec services cloud (Google Vision, AWS Textract)
- Tester avec différents types et tailles de fichiers

### Prompt 3.3 : Module de Recommandations Intelligentes

🎯 **But** : Développer le système de recommandations intelligentes de prestataires basé sur l'IA, l'historique des événements, les préférences clients, et l'analyse prédictive

🧠 **Contexte** : Module d'IA dans `apps/backoffice/src/app/providers/recommendations` utilisant algorithmes de machine learning, analyse de données historiques, et patterns de recommandation pour optimiser la sélection de prestataires.

🛠️ **Fichiers** :
- `apps/backoffice/src/app/providers/recommendations/page.tsx`
- `apps/backoffice/src/app/providers/recommendations/components/RecommendationEngine.tsx`
- `apps/backoffice/src/app/providers/recommendations/components/MatchingCriteria.tsx`
- `apps/backoffice/src/app/providers/recommendations/components/PerformancePredictor.tsx`
- `apps/backoffice/src/app/providers/recommendations/components/ClientPreferences.tsx`
- `apps/backoffice/src/app/providers/recommendations/components/RecommendationHistory.tsx`
- `supabase/functions/generate-provider-recommendations/index.ts`
- `supabase/functions/analyze-provider-performance/index.ts`

🔄 **Comportement** :
Créer la page principale `recommendations/page.tsx` avec interface de recommandation : saisie des critères d'événement, algorithmes de matching disponibles, résultats de recommandations avec scores, comparaison des prestataires suggérés, sauvegarde des recommandations.

Développer `RecommendationEngine` avec algorithmes multiples : matching par similarité (événements passés similaires), scoring basé sur performance historique, analyse des préférences client, optimisation budget/qualité, prise en compte de la disponibilité, pondération des critères personnalisables.

Implémenter `MatchingCriteria` avec configuration : type d'événement, budget disponible, localisation, nombre d'invités, style souhaité, contraintes spéciales, préférences qualité/prix, historique client, critères d'exclusion, pondération des facteurs.

Créer `PerformancePredictor` avec prédictions : probabilité de succès par prestataire, prédiction de satisfaction client, estimation de respect des délais, analyse des risques, recommandations d'amélioration, alertes de performance.

Développer `ClientPreferences` avec profiling : analyse des choix passés du client, identification des patterns de préférence, segmentation client automatique, personnalisation des recommandations, apprentissage continu des préférences.

Implémenter `RecommendationHistory` avec historique : toutes les recommandations générées, taux de conversion par algorithme, feedback sur les recommandations, amélioration continue des modèles, analyse de performance des suggestions.

Créer les Edge Functions : `generate-provider-recommendations` pour génération de recommandations basées sur critères multiples, `analyze-provider-performance` pour analyse prédictive de performance, intégration avec APIs d'IA externes si nécessaire.

Intégrer machine learning : modèles de classification pour catégorisation automatique, clustering pour segmentation de prestataires, réseaux de neurones pour prédiction de satisfaction, algorithmes génétiques pour optimisation multi-critères.

⚙️ **Interactions** :
- **Analyse** : Données historiques Événements, Prestataires, Clients
- **Prédit** : Performance, satisfaction, compatibilité
- **Recommande** : Prestataires optimaux selon critères
- **Apprend** : Feedback utilisateur, résultats réels

💡 **Tips Windsurf** :
- Utiliser Edge Functions pour calculs d'IA intensifs
- Implémenter algorithmes de recommandation progressifs
- Intégrer APIs d'IA externes (OpenAI, Google AI) si nécessaire
- Optimiser performance avec cache des recommandations fréquentes
- Tester avec données historiques réelles pour validation

---

## Section 4 : Évolutions Futures

### Prompt 4.1 : Intelligence Artificielle et Automatisation Avancée

🎯 **But** : Implémenter les fonctionnalités d'IA avancée pour le module Gestion des Prestataires avec analyse prédictive, automatisation des workflows, chatbot intelligent, et optimisation continue

🧠 **Contexte** : Module d'IA avancée dans `apps/backoffice/src/app/providers/ai` intégrant OpenAI, modèles de machine learning, et automatisation intelligente des processus métier.

🛠️ **Fichiers** :
- `apps/backoffice/src/app/providers/ai/page.tsx`
- `apps/backoffice/src/app/providers/ai/components/AIAssistant.tsx`
- `apps/backoffice/src/app/providers/ai/components/PredictiveAnalytics.tsx`
- `apps/backoffice/src/app/providers/ai/components/AutomationRules.tsx`
- `apps/backoffice/src/app/providers/ai/components/PerformanceOptimizer.tsx`
- `supabase/functions/ai-provider-analysis/index.ts`
- `supabase/functions/automated-provider-scoring/index.ts`
- `supabase/functions/intelligent-matching/index.ts`

🔄 **Comportement** :
Créer la page principale `ai/page.tsx` avec tableau de bord IA : statut des modèles d'IA, analyses en cours, recommandations automatiques générées, optimisations suggérées, métriques de performance IA, configuration des algorithmes.

Développer `AIAssistant` avec chatbot intelligent : interface conversationnelle pour recherche de prestataires, réponses aux questions sur performances, suggestions d'optimisation, aide à la décision, intégration avec base de connaissances, apprentissage continu.

Implémenter `PredictiveAnalytics` avec analyses prédictives : prédiction de demande par catégorie de prestataires, identification des prestataires à risque, prévision de satisfaction client, optimisation des tarifs de commission, détection d'opportunités de croissance.

Créer `AutomationRules` avec règles intelligentes : validation automatique des documents par IA, scoring automatique des nouveaux prestataires, détection d'anomalies dans les commissions, alertes prédictives, workflows adaptatifs selon contexte.

Développer `PerformanceOptimizer` avec optimisation continue : analyse des goulots d'étranglement, suggestions d'amélioration des processus, optimisation des algorithmes de matching, personnalisation automatique des interfaces, amélioration continue des modèles.

Créer les Edge Functions IA : `ai-provider-analysis` pour analyse intelligente des profils prestataires, `automated-provider-scoring` pour scoring automatique basé sur multiples critères, `intelligent-matching` pour matching avancé événement-prestataire.

Intégrer modèles d'IA : traitement du langage naturel pour analyse des avis clients, vision par ordinateur pour validation automatique des documents, apprentissage automatique pour optimisation des recommandations, réseaux de neurones pour prédiction de performance.

⚙️ **Interactions** :
- **Analyse** : Toutes les données du module avec IA avancée
- **Automatise** : Workflows répétitifs, validations, scoring
- **Prédit** : Tendances, performances, opportunités
- **Optimise** : Processus, algorithmes, expérience utilisateur

💡 **Tips Windsurf** :
- Intégrer OpenAI API pour traitement du langage naturel
- Utiliser modèles de machine learning spécialisés
- Implémenter apprentissage continu avec feedback utilisateur
- Optimiser coûts IA avec cache intelligent
- Tester modèles avec données de validation

### Prompt 4.2 : Intégration Écosystème et API Publique

🎯 **But** : Développer l'écosystème d'intégrations externes avec API publique, webhooks, marketplace de prestataires, et connecteurs avec plateformes tierces

🧠 **Contexte** : Module d'intégration dans `apps/backoffice/src/app/providers/integrations` exposant APIs publiques sécurisées, gérant les webhooks, et facilitant l'intégration avec systèmes externes.

🛠️ **Fichiers** :
- `apps/backoffice/src/app/providers/integrations/page.tsx`
- `apps/backoffice/src/app/providers/integrations/components/APIManagement.tsx`
- `apps/backoffice/src/app/providers/integrations/components/WebhookManager.tsx`
- `apps/backoffice/src/app/providers/integrations/components/ThirdPartyConnectors.tsx`
- `apps/backoffice/src/app/providers/integrations/components/MarketplaceSync.tsx`
- `supabase/functions/public-api-providers/index.ts`
- `supabase/functions/webhook-dispatcher/index.ts`
- `supabase/functions/marketplace-sync/index.ts`

🔄 **Comportement** :
Créer la page principale `integrations/page.tsx` avec gestion des intégrations : APIs actives, webhooks configurés, connecteurs tiers, statistiques d'utilisation, documentation interactive, gestion des clés d'API.

Développer `APIManagement` avec gestion complète : création de clés d'API, gestion des permissions par endpoint, limitation de taux, monitoring d'utilisation, documentation automatique (Swagger), versioning des APIs, analytics d'utilisation.

Implémenter `WebhookManager` avec système de webhooks : configuration des événements à écouter, gestion des URLs de destination, retry automatique en cas d'échec, logs détaillés, test des webhooks, sécurisation avec signatures.

Créer `ThirdPartyConnectors` avec connecteurs : intégration avec plateformes de mariage (The Knot, WeddingWire), synchronisation avec réseaux sociaux, connecteurs comptables (QuickBooks, Sage), APIs de géolocalisation, services de communication.

Développer `MarketplaceSync` avec marketplace : synchronisation avec marketplaces externes, gestion des profils multi-plateformes, optimisation SEO automatique, synchronisation des avis et notations, gestion centralisée des tarifs.

Créer les Edge Functions publiques : `public-api-providers` pour exposition sécurisée des données prestataires, `webhook-dispatcher` pour distribution des événements, `marketplace-sync` pour synchronisation avec plateformes externes.

Implémenter sécurité avancée : authentification OAuth 2.0, limitation de taux par client, chiffrement des données sensibles, audit trail complet, gestion des permissions granulaires, protection contre les attaques.

⚙️ **Interactions** :
- **Expose** : APIs publiques sécurisées pour données prestataires
- **Synchronise** : Plateformes externes, marketplaces, réseaux sociaux
- **Notifie** : Systèmes externes via webhooks
- **Intègre** : Écosystème de partenaires et plateformes

💡 **Tips Windsurf** :
- Utiliser standards OpenAPI pour documentation automatique
- Implémenter rate limiting et sécurité robuste
- Créer SDK pour faciliter intégrations tierces
- Monitorer performance et utilisation des APIs
- Tester intégrations avec environnements sandbox

### Prompt 4.3 : Expérience Immersive et Collaboration Avancée

🎯 **But** : Créer l'expérience immersive du module Gestion des Prestataires avec réalité virtuelle/augmentée, collaboration temps réel, et interfaces innovantes

🧠 **Contexte** : Module d'expérience avancée dans `apps/backoffice/src/app/providers/immersive` utilisant technologies émergentes, WebRTC pour collaboration, et interfaces 3D.

🛠️ **Fichiers** :
- `apps/backoffice/src/app/providers/immersive/page.tsx`
- `apps/backoffice/src/app/providers/immersive/components/VRShowroom.tsx`
- `apps/backoffice/src/app/providers/immersive/components/ARPreview.tsx`
- `apps/backoffice/src/app/providers/immersive/components/CollaborativeWorkspace.tsx`
- `apps/backoffice/src/app/providers/immersive/components/3DPortfolioViewer.tsx`
- `apps/backoffice/src/app/providers/immersive/components/VirtualMeetings.tsx`

🔄 **Comportement** :
Créer la page principale `immersive/page.tsx` avec hub d'expériences : accès aux showrooms VR, prévisualisations AR, espaces collaboratifs actifs, portfolios 3D, réunions virtuelles planifiées, statistiques d'engagement.

Développer `VRShowroom` avec showroom virtuel : environnements 3D immersifs pour présentation des prestataires, navigation intuitive, interactions avec éléments 3D, présentation de portfolios en réalité virtuelle, expérience multi-utilisateurs.

Implémenter `ARPreview` avec réalité augmentée : prévisualisation des services en AR, intégration avec caméra pour superposition, essais virtuels de décoration/éclairage, partage d'expériences AR, capture et sauvegarde de configurations.

Créer `CollaborativeWorkspace` avec collaboration temps réel : espaces de travail partagés, édition collaborative de projets, communication vidéo intégrée, partage d'écran et documents, annotations collaboratives, historique des sessions.

Développer `3DPortfolioViewer` avec portfolios immersifs : galeries 3D interactives, modèles 3D des réalisations, visite virtuelle des événements passés, comparaison visuelle de styles, intégration avec données de performance.

Implémenter `VirtualMeetings` avec réunions virtuelles : salles de réunion virtuelles, avatars personnalisés, partage de contenu immersif, enregistrement des sessions, intégration calendrier, outils de présentation 3D.

Intégrer technologies émergentes : WebXR pour expériences cross-platform, WebRTC pour communication temps réel, Three.js pour rendu 3D, IA pour génération de contenu immersif, blockchain pour authentification des portfolios.

⚙️ **Interactions** :
- **Immerse** : Expériences VR/AR pour prestataires et clients
- **Collabore** : Espaces de travail partagés temps réel
- **Présente** : Portfolios et services en 3D immersif
- **Connecte** : Réunions virtuelles multi-participants

💡 **Tips Windsurf** :
- Utiliser WebXR pour compatibilité cross-platform VR/AR
- Implémenter progressive enhancement pour accessibilité
- Optimiser performance pour expériences fluides
- Intégrer WebRTC pour collaboration temps réel
- Tester sur différents dispositifs VR/AR

---

## Validation et Cohérence Inter-Modules

### Validation Technique Complète

Cette série de prompts Windsurf pour le module Gestion des Prestataires respecte intégralement les spécifications techniques analysées dans les documents fournis, assurant une cohérence parfaite avec l'architecture globale de l'ERP Wedding Collection. L'approche multi-portails (Backoffice, Vendor Portal, Client Portal) est intégrée dans chaque prompt, garantissant une synchronisation harmonieuse des données et des workflows.

La structure en quatre sections (Initialisation, Fonctionnalités principales, Fonctionnalités secondaires, Évolutions futures) optimise l'efficacité de développement avec Windsurf en priorisant les éléments critiques tout en préparant l'évolution vers des fonctionnalités avancées. Chaque prompt intègre les contraintes métier spécifiques identifiées dans l'analyse documentaire, notamment la gestion complexe des commissions, la validation multi-niveaux, et la synchronisation temps réel.

L'intégration avec les modules existants (Lieux, Suivi des Mariages, Comptabilité et Facturation, Contrats, Planning Ménage) est soigneusement orchestrée dans chaque prompt, assurant la cohérence des données partagées et l'efficacité des workflows transversaux. Cette approche garantit que le module Gestion des Prestataires s'intègre naturellement dans l'écosystème ERP tout en apportant sa valeur métier spécialisée.

### Recommandations d'Exécution

Pour une implémentation optimale avec Windsurf, il est recommandé de commencer par l'exécution séquentielle des prompts de la Section 1 (Initialisation) en mode Cascade Write pour bénéficier de la génération automatique des fichiers liés. L'utilisation du MCP Supabase est particulièrement recommandée pour les prompts 1.1 et 1.3 afin de valider directement la cohérence du schéma et des Edge Functions.

Les prompts de la Section 2 (Fonctionnalités principales) peuvent être exécutés en parallèle une fois l'initialisation terminée, en utilisant le mode Cascade Chat pour les logiques métier complexes comme la gestion des commissions (prompt 2.3) et la synchronisation multi-portails (prompt 2.4). La référence aux patterns existants via /Reference Open Editors optimisera la cohérence avec les modules déjà développés.

L'exécution des Sections 3 et 4 peut être planifiée selon les priorités métier, les fonctionnalités d'analytics (Section 3) apportant une valeur immédiate tandis que les évolutions futures (Section 4) préparent l'innovation à long terme. L'utilisation de Claude 3.5 Sonnet est recommandée pour les prompts impliquant de l'IA et des algorithmes complexes.

Cette méthodologie de transformation de cahiers des charges en prompts Windsurf structurés démontre l'efficacité de l'approche pour des modules complexes multi-portails, garantissant un développement rapide, robuste, et parfaitement intégré dans l'écosystème ERP Wedding Collection.

