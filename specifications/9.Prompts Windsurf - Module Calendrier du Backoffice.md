# Prompts Windsurf - Module Calendrier du Backoffice

**Version**: 1.0  
**Date**: 2025-06-03  
**Auteur**: Expert Windsurf - Agent IA  
**Module**: Calendrier - Backoffice ERP Wedding Collection  
**Stack**: Next.js 14 + Supabase + Tailwind CSS + ShadCN UI + Lucide Icons

---

## üìã Introduction et Contexte

Le module Calendrier du Backoffice constitue l'interface de visualisation temporelle centrale de l'ERP Wedding Collection. Contrairement aux autres modules qui g√®rent des donn√©es, ce module est **exclusivement en lecture seule** et offre une vue calendaire unifi√©e de tous les √©v√©nements, avec filtrage avanc√© et acc√®s aux documents associ√©s.

### üéØ Objectifs du Module
- **Vue temporelle centralis√©e** : Visualisation calendaire de tous les √©v√©nements
- **Consultation optimis√©e** : Interface rapide et intuitive pour les √©quipes
- **Filtrage intelligent** : Par lieu, statut, p√©riode avec mise √† jour temps r√©el
- **Acc√®s documentaire** : Liens directs vers les documents √©v√©nement
- **Int√©gration parfaite** : Synchronisation avec modules √âv√©nement et Lieux

### üèóÔ∏è Architecture Technique
- **Lecture seule** : Aucune modification de donn√©es, consultation pure
- **Temps r√©el** : Supabase Realtime pour synchronisation automatique
- **Performance** : Optimisations sp√©cifiques pour requ√™tes temporelles
- **S√©curit√©** : RLS et permissions h√©rit√©es des modules sources

---

## üèóÔ∏è Section 1 : Initialisation

### 01 - Configuration des fonctions RPC backend

üéØ **But :** Cr√©er les fonctions RPC Supabase optimis√©es pour les requ√™tes calendaires avec gestion des plages de dates et filtrage par lieu.

üß† **Contexte technique :** Le module Calendrier n√©cessite des fonctions RPC sp√©cialis√©es pour r√©cup√©rer efficacement les √©v√©nements sur des plages de dates avec filtrage optionnel. Ces fonctions doivent √™tre optimis√©es pour les performances et respecter les politiques RLS existantes.

üõ†Ô∏è **Type de fichier :** `.sql` (migrations Supabase)

üîÑ **Comportement attendu :**
Cr√©er les fonctions RPC suivantes dans Supabase :

**Fonction get_calendar_events :**
```sql
CREATE OR REPLACE FUNCTION public.get_calendar_events(
  p_start_date timestamptz,
  p_end_date timestamptz,
  p_venue_ids uuid[] DEFAULT NULL,
  p_statuses text[] DEFAULT NULL
)
RETURNS TABLE (
  id uuid,
  name text,
  status text,
  start_date timestamptz,
  end_date timestamptz,
  venue_id uuid,
  venue_name text,
  client_name text,
  document_urls jsonb,
  metadata jsonb
)
LANGUAGE sql
SECURITY DEFINER
AS $$
  SELECT 
    e.id,
    e.name,
    e.status,
    e.start_date,
    e.end_date,
    e.venue_id,
    v.name as venue_name,
    CONCAT(c.first_name, ' ', c.last_name) as client_name,
    e.document_urls,
    e.metadata
  FROM shared.events e
  LEFT JOIN shared.venues v ON e.venue_id = v.id
  LEFT JOIN shared.clients c ON e.client_id = c.id
  WHERE 
    -- √âv√©nements qui intersectent avec la p√©riode
    (e.start_date <= p_end_date AND e.end_date >= p_start_date)
    -- Filtre optionnel par lieux
    AND (p_venue_ids IS NULL OR e.venue_id = ANY(p_venue_ids))
    -- Filtre optionnel par statuts
    AND (p_statuses IS NULL OR e.status = ANY(p_statuses))
  ORDER BY e.start_date ASC;
$$;
```

**Fonction get_calendar_venues :**
```sql
CREATE OR REPLACE FUNCTION public.get_calendar_venues()
RETURNS TABLE (
  id uuid,
  name text,
  status text,
  event_count bigint
)
LANGUAGE sql
SECURITY DEFINER
AS $$
  SELECT 
    v.id,
    v.name,
    v.status,
    COUNT(e.id) as event_count
  FROM shared.venues v
  LEFT JOIN shared.events e ON v.id = e.venue_id 
    AND e.start_date >= CURRENT_DATE - INTERVAL '1 month'
    AND e.start_date <= CURRENT_DATE + INTERVAL '6 months'
  WHERE v.status = 'active'
  GROUP BY v.id, v.name, v.status
  ORDER BY v.name ASC;
$$;
```

**Fonction get_calendar_stats :**
```sql
CREATE OR REPLACE FUNCTION public.get_calendar_stats(
  p_start_date timestamptz,
  p_end_date timestamptz
)
RETURNS TABLE (
  total_events bigint,
  events_by_status jsonb,
  events_by_venue jsonb,
  occupancy_rate numeric
)
LANGUAGE sql
SECURITY DEFINER
AS $$
  SELECT 
    COUNT(*) as total_events,
    jsonb_object_agg(status, status_count) as events_by_status,
    jsonb_object_agg(venue_name, venue_count) as events_by_venue,
    ROUND(
      (COUNT(*) * 100.0) / 
      NULLIF(EXTRACT(days FROM p_end_date - p_start_date) * 
        (SELECT COUNT(*) FROM shared.venues WHERE status = 'active'), 0), 
      2
    ) as occupancy_rate
  FROM (
    SELECT 
      e.status,
      COUNT(*) as status_count,
      v.name as venue_name,
      COUNT(*) as venue_count
    FROM shared.events e
    LEFT JOIN shared.venues v ON e.venue_id = v.id
    WHERE e.start_date >= p_start_date AND e.start_date <= p_end_date
    GROUP BY GROUPING SETS ((e.status), (v.name))
  ) stats;
$$;
```

‚öôÔ∏è **Interactions :** 
- Utilise les tables shared.events, shared.venues, shared.clients
- Respecte les politiques RLS existantes
- Optimis√© pour les requ√™tes fr√©quentes du calendrier

üí° **Tips Windsurf :** Teste les performances avec EXPLAIN ANALYZE. Utilise des index sur start_date, end_date, venue_id. Valide que les politiques RLS s'appliquent correctement.

---

### 02 - Cr√©ation des types TypeScript pour le calendrier

üéØ **But :** D√©finir les types TypeScript sp√©cifiques au module Calendrier pour assurer la coh√©rence des donn√©es et l'autocompl√©tion.

üß† **Contexte technique :** Le module Calendrier manipule des structures de donn√©es sp√©cifiques pour l'affichage calendaire, les filtres et les √©v√©nements. Ces types doivent √™tre coh√©rents avec les modules sources tout en √©tant optimis√©s pour l'affichage.

üõ†Ô∏è **Type de fichier :** `.ts` (types)

üîÑ **Comportement attendu :**
Cr√©er le fichier `src/modules/calendar-module/types/calendar.ts` :

```typescript
import { Database } from '@/types/supabase';

// Types de base extraits de la base de donn√©es
export type Event = Database['public']['Tables']['events']['Row'];
export type Venue = Database['public']['Tables']['venues']['Row'];

// Types sp√©cifiques au calendrier
export interface CalendarEvent {
  id: string;
  name: string;
  status: EventStatus;
  start_date: string;
  end_date: string;
  venue_id?: string;
  venue_name?: string;
  client_name: string;
  document_urls?: DocumentUrls;
  metadata?: EventMetadata;
  // Propri√©t√©s calcul√©es pour l'affichage
  duration_days: number;
  is_multi_day: boolean;
  display_color: string;
  abbreviation?: string;
}

export interface CalendarVenue {
  id: string;
  name: string;
  status: string;
  event_count: number;
  is_selected?: boolean;
}

export interface CalendarStats {
  total_events: number;
  events_by_status: Record<string, number>;
  events_by_venue: Record<string, number>;
  occupancy_rate: number;
}

// Types pour les filtres
export interface CalendarFilters {
  venue_ids: string[];
  statuses: EventStatus[];
  start_date: Date;
  end_date: Date;
}

export interface CalendarViewOptions {
  view_type: 'month' | 'week' | 'day';
  show_weekends: boolean;
  show_past_events: boolean;
  compact_mode: boolean;
}

// Types pour les √©v√©nements UI
export interface CalendarEventClick {
  event: CalendarEvent;
  date: Date;
  position: { x: number; y: number };
}

export interface CalendarDateClick {
  date: Date;
  has_events: boolean;
  events: CalendarEvent[];
}

// Types pour les statuts d'√©v√©nement
export type EventStatus = 
  | 'draft'
  | 'confirmed'
  | 'in_progress'
  | 'completed'
  | 'cancelled'
  | 'postponed';

export const EVENT_STATUS_CONFIG: Record<EventStatus, {
  label: string;
  color: string;
  bg_color: string;
  text_color: string;
}> = {
  draft: {
    label: 'Brouillon',
    color: '#6B7280',
    bg_color: '#F3F4F6',
    text_color: '#374151'
  },
  confirmed: {
    label: 'Confirm√©',
    color: '#059669',
    bg_color: '#D1FAE5',
    text_color: '#065F46'
  },
  in_progress: {
    label: 'En cours',
    color: '#D97706',
    bg_color: '#FEF3C7',
    text_color: '#92400E'
  },
  completed: {
    label: 'Termin√©',
    color: '#7C3AED',
    bg_color: '#EDE9FE',
    text_color: '#5B21B6'
  },
  cancelled: {
    label: 'Annul√©',
    color: '#DC2626',
    bg_color: '#FEE2E2',
    text_color: '#991B1B'
  },
  postponed: {
    label: 'Report√©',
    color: '#EA580C',
    bg_color: '#FED7AA',
    text_color: '#9A3412'
  }
};

// Types pour les documents
export interface DocumentUrls {
  event_sheet?: DocumentInfo;
  seating_plan?: DocumentInfo;
  accommodation_plan?: DocumentInfo;
  [key: string]: DocumentInfo | undefined;
}

export interface DocumentInfo {
  path: string;
  name: string;
  type: string;
  size?: number;
  uploaded_at?: string;
}

// Types pour les m√©tadonn√©es d'√©v√©nement
export interface EventMetadata {
  guest_count?: number;
  event_type?: string;
  special_requirements?: string;
  abbreviations?: string[];
  color_override?: string;
  priority?: 'low' | 'medium' | 'high';
  tags?: string[];
}

// Types pour les hooks
export interface UseCalendarEventsResult {
  events: CalendarEvent[];
  isLoading: boolean;
  error: Error | null;
  refetch: () => void;
}

export interface UseCalendarVenuesResult {
  venues: CalendarVenue[];
  isLoading: boolean;
  error: Error | null;
}

export interface UseCalendarStatsResult {
  stats: CalendarStats | null;
  isLoading: boolean;
  error: Error | null;
}

// Types pour les utilitaires de date
export interface CalendarMonth {
  year: number;
  month: number; // 0-11
  days: CalendarDay[];
  weeks: CalendarWeek[];
}

export interface CalendarDay {
  date: Date;
  is_current_month: boolean;
  is_today: boolean;
  is_weekend: boolean;
  events: CalendarEvent[];
  event_count: number;
}

export interface CalendarWeek {
  week_number: number;
  days: CalendarDay[];
}
```

‚öôÔ∏è **Interactions :** 
- Coh√©rent avec les types des modules √âv√©nement et Lieux
- Utilise les types Supabase g√©n√©r√©s automatiquement
- Optimis√© pour l'affichage et la manipulation calendaire

üí° **Tips Windsurf :** Utilise les types g√©n√©r√©s par Supabase CLI. Assure-toi que les couleurs respectent le design system. Valide la coh√©rence avec les autres modules.

---

### 03 - Configuration des services de donn√©es

üéØ **But :** Cr√©er les services de donn√©es pour l'acc√®s aux √©v√©nements calendaires avec cache intelligent et gestion d'erreurs.

üß† **Contexte technique :** Les services de donn√©es encapsulent l'acc√®s aux fonctions RPC Supabase et fournissent une couche d'abstraction avec cache, retry et transformation des donn√©es pour l'affichage calendaire.

üõ†Ô∏è **Type de fichier :** `.ts` (services)

üîÑ **Comportement attendu :**
Cr√©er le fichier `src/modules/calendar-module/services/calendar-data.service.ts` :

```typescript
import { supabase } from '@/lib/supabase';
import { 
  CalendarEvent, 
  CalendarVenue, 
  CalendarStats, 
  CalendarFilters,
  EVENT_STATUS_CONFIG 
} from '../types/calendar';
import { addDays, differenceInDays, format } from 'date-fns';
import { fr } from 'date-fns/locale';

export class CalendarDataService {
  private static instance: CalendarDataService;
  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();
  
  static getInstance(): CalendarDataService {
    if (!CalendarDataService.instance) {
      CalendarDataService.instance = new CalendarDataService();
    }
    return CalendarDataService.instance;
  }

  // Cache avec TTL
  private setCache(key: string, data: any, ttlMinutes: number = 5): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl: ttlMinutes * 60 * 1000
    });
  }

  private getCache(key: string): any | null {
    const cached = this.cache.get(key);
    if (!cached) return null;
    
    if (Date.now() - cached.timestamp > cached.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    return cached.data;
  }

  // R√©cup√©ration des √©v√©nements avec cache
  async getCalendarEvents(filters: CalendarFilters): Promise<CalendarEvent[]> {
    const cacheKey = `events_${JSON.stringify(filters)}`;
    const cached = this.getCache(cacheKey);
    if (cached) return cached;

    try {
      const { data, error } = await supabase.rpc('get_calendar_events', {
        p_start_date: filters.start_date.toISOString(),
        p_end_date: filters.end_date.toISOString(),
        p_venue_ids: filters.venue_ids.length > 0 ? filters.venue_ids : null,
        p_statuses: filters.statuses.length > 0 ? filters.statuses : null
      });

      if (error) throw error;

      const transformedEvents = data.map(this.transformEventForCalendar);
      this.setCache(cacheKey, transformedEvents, 3); // Cache 3 minutes
      
      return transformedEvents;
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration des √©v√©nements:', error);
      throw new Error('Impossible de charger les √©v√©nements du calendrier');
    }
  }

  // R√©cup√©ration des lieux avec cache
  async getCalendarVenues(): Promise<CalendarVenue[]> {
    const cacheKey = 'calendar_venues';
    const cached = this.getCache(cacheKey);
    if (cached) return cached;

    try {
      const { data, error } = await supabase.rpc('get_calendar_venues');
      
      if (error) throw error;

      const venues = data.map(venue => ({
        ...venue,
        is_selected: false
      }));

      this.setCache(cacheKey, venues, 10); // Cache 10 minutes
      return venues;
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration des lieux:', error);
      throw new Error('Impossible de charger la liste des lieux');
    }
  }

  // R√©cup√©ration des statistiques
  async getCalendarStats(startDate: Date, endDate: Date): Promise<CalendarStats> {
    const cacheKey = `stats_${startDate.toISOString()}_${endDate.toISOString()}`;
    const cached = this.getCache(cacheKey);
    if (cached) return cached;

    try {
      const { data, error } = await supabase.rpc('get_calendar_stats', {
        p_start_date: startDate.toISOString(),
        p_end_date: endDate.toISOString()
      });

      if (error) throw error;

      const stats = data[0] || {
        total_events: 0,
        events_by_status: {},
        events_by_venue: {},
        occupancy_rate: 0
      };

      this.setCache(cacheKey, stats, 5); // Cache 5 minutes
      return stats;
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration des statistiques:', error);
      throw new Error('Impossible de charger les statistiques');
    }
  }

  // G√©n√©ration d'URL sign√©e pour document
  async getDocumentSignedUrl(path: string): Promise<string> {
    try {
      const { data, error } = await supabase.storage
        .from('documents')
        .createSignedUrl(path, 3600); // 1 heure

      if (error) throw error;
      return data.signedUrl;
    } catch (error) {
      console.error('Erreur lors de la g√©n√©ration de l\'URL sign√©e:', error);
      throw new Error('Impossible d\'acc√©der au document');
    }
  }

  // Transformation d'un √©v√©nement pour l'affichage calendaire
  private transformEventForCalendar = (event: any): CalendarEvent => {
    const startDate = new Date(event.start_date);
    const endDate = new Date(event.end_date);
    const durationDays = differenceInDays(endDate, startDate) + 1;
    const isMultiDay = durationDays > 1;

    // G√©n√©ration de l'abr√©viation
    const abbreviation = this.generateAbbreviation(event);

    // Couleur d'affichage
    const statusConfig = EVENT_STATUS_CONFIG[event.status as keyof typeof EVENT_STATUS_CONFIG];
    const displayColor = event.metadata?.color_override || statusConfig?.color || '#6B7280';

    return {
      id: event.id,
      name: event.name,
      status: event.status,
      start_date: event.start_date,
      end_date: event.end_date,
      venue_id: event.venue_id,
      venue_name: event.venue_name,
      client_name: event.client_name,
      document_urls: event.document_urls,
      metadata: event.metadata,
      duration_days: durationDays,
      is_multi_day: isMultiDay,
      display_color: displayColor,
      abbreviation
    };
  };

  // G√©n√©ration d'abr√©viation intelligente
  private generateAbbreviation(event: any): string {
    // Priorit√© aux abr√©viations personnalis√©es
    if (event.metadata?.abbreviations?.length > 0) {
      return event.metadata.abbreviations[0];
    }

    // G√©n√©ration automatique bas√©e sur le nom du client
    if (event.client_name) {
      const names = event.client_name.split(' ');
      if (names.length >= 2) {
        return `${names[0][0]}${names[names.length - 1][0]}`.toUpperCase();
      }
      return names[0].substring(0, 2).toUpperCase();
    }

    // Fallback sur le nom de l'√©v√©nement
    const words = event.name.split(' ');
    if (words.length >= 2) {
      return `${words[0][0]}${words[1][0]}`.toUpperCase();
    }
    return event.name.substring(0, 2).toUpperCase();
  }

  // Invalidation du cache
  invalidateCache(pattern?: string): void {
    if (pattern) {
      for (const key of this.cache.keys()) {
        if (key.includes(pattern)) {
          this.cache.delete(key);
        }
      }
    } else {
      this.cache.clear();
    }
  }

  // Pr√©chargement intelligent
  async preloadAdjacentMonths(currentDate: Date): Promise<void> {
    const previousMonth = addDays(currentDate, -30);
    const nextMonth = addDays(currentDate, 30);

    // Pr√©chargement en arri√®re-plan sans attendre
    Promise.all([
      this.getCalendarEvents({
        start_date: previousMonth,
        end_date: addDays(previousMonth, 30),
        venue_ids: [],
        statuses: []
      }),
      this.getCalendarEvents({
        start_date: nextMonth,
        end_date: addDays(nextMonth, 30),
        venue_ids: [],
        statuses: []
      })
    ]).catch(error => {
      console.warn('Erreur lors du pr√©chargement:', error);
    });
  }
}

// Export de l'instance singleton
export const calendarDataService = CalendarDataService.getInstance();
```

‚öôÔ∏è **Interactions :** 
- Utilise les fonctions RPC cr√©√©es dans le prompt 01
- Int√®gre avec Supabase Storage pour les documents
- Cache intelligent pour optimiser les performances

üí° **Tips Windsurf :** Impl√©mente un retry mechanism pour les requ√™tes √©chou√©es. Utilise des Web Workers pour le pr√©chargement. Monitore les performances du cache.

---

### 04 - Cr√©ation des hooks React personnalis√©s

üéØ **But :** D√©velopper les hooks React personnalis√©s pour la gestion d'√©tat du calendrier avec optimisations de performance et synchronisation temps r√©el.

üß† **Contexte technique :** Les hooks encapsulent la logique m√©tier du calendrier et fournissent une interface r√©active pour les composants. Ils int√®grent TanStack Query pour le cache et Supabase Realtime pour les mises √† jour automatiques.

üõ†Ô∏è **Type de fichier :** `.ts` (hooks)

üîÑ **Comportement attendu :**
Cr√©er le fichier `src/modules/calendar-module/hooks/use-calendar.ts` :

```typescript
import { useState, useEffect, useCallback, useMemo } from 'react';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { calendarDataService } from '../services/calendar-data.service';
import { supabase } from '@/lib/supabase';
import { 
  CalendarEvent, 
  CalendarVenue, 
  CalendarStats, 
  CalendarFilters,
  CalendarViewOptions,
  UseCalendarEventsResult,
  UseCalendarVenuesResult,
  UseCalendarStatsResult
} from '../types/calendar';
import { 
  startOfMonth, 
  endOfMonth, 
  addMonths, 
  subMonths,
  format,
  isSameMonth 
} from 'date-fns';
import { fr } from 'date-fns/locale';

// Hook principal pour les √©v√©nements du calendrier
export function useCalendarEvents(filters: CalendarFilters): UseCalendarEventsResult {
  const queryClient = useQueryClient();

  const {
    data: events = [],
    isLoading,
    error,
    refetch
  } = useQuery({
    queryKey: ['calendar-events', filters],
    queryFn: () => calendarDataService.getCalendarEvents(filters),
    staleTime: 2 * 60 * 1000, // 2 minutes
    cacheTime: 5 * 60 * 1000, // 5 minutes
    refetchOnWindowFocus: false,
    retry: 2
  });

  // Souscription aux changements temps r√©el
  useEffect(() => {
    const channel = supabase
      .channel('calendar-events-changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'shared',
          table: 'events'
        },
        (payload) => {
          console.log('√âv√©nement modifi√©:', payload);
          // Invalidation du cache pour forcer le rechargement
          queryClient.invalidateQueries({ queryKey: ['calendar-events'] });
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [queryClient]);

  // Pr√©chargement des mois adjacents
  useEffect(() => {
    if (events.length > 0) {
      calendarDataService.preloadAdjacentMonths(filters.start_date);
    }
  }, [filters.start_date, events.length]);

  return {
    events,
    isLoading,
    error: error as Error | null,
    refetch
  };
}

// Hook pour les lieux du calendrier
export function useCalendarVenues(): UseCalendarVenuesResult {
  const {
    data: venues = [],
    isLoading,
    error
  } = useQuery({
    queryKey: ['calendar-venues'],
    queryFn: () => calendarDataService.getCalendarVenues(),
    staleTime: 10 * 60 * 1000, // 10 minutes
    cacheTime: 30 * 60 * 1000, // 30 minutes
    refetchOnWindowFocus: false
  });

  return {
    venues,
    isLoading,
    error: error as Error | null
  };
}

// Hook pour les statistiques du calendrier
export function useCalendarStats(startDate: Date, endDate: Date): UseCalendarStatsResult {
  const {
    data: stats = null,
    isLoading,
    error
  } = useQuery({
    queryKey: ['calendar-stats', startDate.toISOString(), endDate.toISOString()],
    queryFn: () => calendarDataService.getCalendarStats(startDate, endDate),
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 15 * 60 * 1000, // 15 minutes
    enabled: !!startDate && !!endDate
  });

  return {
    stats,
    isLoading,
    error: error as Error | null
  };
}

// Hook pour la navigation du calendrier
export function useCalendarNavigation(initialDate: Date = new Date()) {
  const [currentDate, setCurrentDate] = useState(initialDate);
  
  const currentMonth = useMemo(() => ({
    start: startOfMonth(currentDate),
    end: endOfMonth(currentDate),
    label: format(currentDate, 'MMMM yyyy', { locale: fr }),
    year: currentDate.getFullYear(),
    month: currentDate.getMonth()
  }), [currentDate]);

  const goToPreviousMonth = useCallback(() => {
    setCurrentDate(prev => subMonths(prev, 1));
  }, []);

  const goToNextMonth = useCallback(() => {
    setCurrentDate(prev => addMonths(prev, 1));
  }, []);

  const goToToday = useCallback(() => {
    setCurrentDate(new Date());
  }, []);

  const goToDate = useCallback((date: Date) => {
    setCurrentDate(date);
  }, []);

  const isCurrentMonth = useMemo(() => {
    return isSameMonth(currentDate, new Date());
  }, [currentDate]);

  return {
    currentDate,
    currentMonth,
    goToPreviousMonth,
    goToNextMonth,
    goToToday,
    goToDate,
    isCurrentMonth
  };
}

// Hook pour les filtres du calendrier
export function useCalendarFilters() {
  const [filters, setFilters] = useState<CalendarFilters>({
    venue_ids: [],
    statuses: [],
    start_date: startOfMonth(new Date()),
    end_date: endOfMonth(new Date())
  });

  const updateVenueFilter = useCallback((venueIds: string[]) => {
    setFilters(prev => ({ ...prev, venue_ids: venueIds }));
  }, []);

  const updateStatusFilter = useCallback((statuses: string[]) => {
    setFilters(prev => ({ ...prev, statuses }));
  }, []);

  const updateDateRange = useCallback((startDate: Date, endDate: Date) => {
    setFilters(prev => ({ 
      ...prev, 
      start_date: startDate, 
      end_date: endDate 
    }));
  }, []);

  const clearFilters = useCallback(() => {
    setFilters({
      venue_ids: [],
      statuses: [],
      start_date: startOfMonth(new Date()),
      end_date: endOfMonth(new Date())
    });
  }, []);

  const hasActiveFilters = useMemo(() => {
    return filters.venue_ids.length > 0 || filters.statuses.length > 0;
  }, [filters]);

  return {
    filters,
    updateVenueFilter,
    updateStatusFilter,
    updateDateRange,
    clearFilters,
    hasActiveFilters
  };
}

// Hook pour les options d'affichage
export function useCalendarViewOptions() {
  const [viewOptions, setViewOptions] = useState<CalendarViewOptions>({
    view_type: 'month',
    show_weekends: true,
    show_past_events: true,
    compact_mode: false
  });

  const updateViewType = useCallback((viewType: 'month' | 'week' | 'day') => {
    setViewOptions(prev => ({ ...prev, view_type: viewType }));
  }, []);

  const toggleWeekends = useCallback(() => {
    setViewOptions(prev => ({ ...prev, show_weekends: !prev.show_weekends }));
  }, []);

  const togglePastEvents = useCallback(() => {
    setViewOptions(prev => ({ ...prev, show_past_events: !prev.show_past_events }));
  }, []);

  const toggleCompactMode = useCallback(() => {
    setViewOptions(prev => ({ ...prev, compact_mode: !prev.compact_mode }));
  }, []);

  return {
    viewOptions,
    updateViewType,
    toggleWeekends,
    togglePastEvents,
    toggleCompactMode
  };
}

// Hook pour l'acc√®s aux documents
export function useDocumentAccess() {
  const [loadingDocuments, setLoadingDocuments] = useState<Set<string>>(new Set());

  const getDocumentUrl = useCallback(async (path: string): Promise<string> => {
    setLoadingDocuments(prev => new Set(prev).add(path));
    
    try {
      const url = await calendarDataService.getDocumentSignedUrl(path);
      return url;
    } catch (error) {
      console.error('Erreur lors de l\'acc√®s au document:', error);
      throw error;
    } finally {
      setLoadingDocuments(prev => {
        const newSet = new Set(prev);
        newSet.delete(path);
        return newSet;
      });
    }
  }, []);

  const isDocumentLoading = useCallback((path: string): boolean => {
    return loadingDocuments.has(path);
  }, [loadingDocuments]);

  return {
    getDocumentUrl,
    isDocumentLoading
  };
}

// Hook combin√© pour l'√©tat complet du calendrier
export function useCalendar() {
  const navigation = useCalendarNavigation();
  const filterState = useCalendarFilters();
  const viewOptions = useCalendarViewOptions();
  const documentAccess = useDocumentAccess();

  // Synchronisation des filtres avec la navigation
  useEffect(() => {
    filterState.updateDateRange(
      navigation.currentMonth.start,
      navigation.currentMonth.end
    );
  }, [navigation.currentMonth.start, navigation.currentMonth.end]);

  const events = useCalendarEvents(filterState.filters);
  const venues = useCalendarVenues();
  const stats = useCalendarStats(
    filterState.filters.start_date,
    filterState.filters.end_date
  );

  return {
    // Navigation
    ...navigation,
    
    // Donn√©es
    events: events.events,
    venues: venues.venues,
    stats: stats.stats,
    
    // √âtats de chargement
    isLoadingEvents: events.isLoading,
    isLoadingVenues: venues.isLoading,
    isLoadingStats: stats.isLoading,
    
    // Erreurs
    eventsError: events.error,
    venuesError: venues.error,
    statsError: stats.error,
    
    // Filtres
    filters: filterState.filters,
    updateVenueFilter: filterState.updateVenueFilter,
    updateStatusFilter: filterState.updateStatusFilter,
    clearFilters: filterState.clearFilters,
    hasActiveFilters: filterState.hasActiveFilters,
    
    // Options d'affichage
    viewOptions: viewOptions.viewOptions,
    updateViewType: viewOptions.updateViewType,
    toggleWeekends: viewOptions.toggleWeekends,
    togglePastEvents: viewOptions.togglePastEvents,
    toggleCompactMode: viewOptions.toggleCompactMode,
    
    // Documents
    getDocumentUrl: documentAccess.getDocumentUrl,
    isDocumentLoading: documentAccess.isDocumentLoading,
    
    // Actions
    refetchEvents: events.refetch
  };
}
```

‚öôÔ∏è **Interactions :** 
- Utilise les services de donn√©es cr√©√©s dans le prompt 03
- Int√®gre TanStack Query pour le cache et la synchronisation
- Supabase Realtime pour les mises √† jour temps r√©el

üí° **Tips Windsurf :** Utilise useCallback et useMemo pour optimiser les performances. Impl√©mente un debounce pour les filtres. G√®re les √©tats de chargement granulaires.

---

### 05 - Utilitaires de manipulation des dates calendaires

üéØ **But :** Cr√©er les utilitaires sp√©cialis√©s pour la manipulation des dates et la g√©n√©ration de structures calendaires optimis√©es.

üß† **Contexte technique :** Le module Calendrier n√©cessite des utilitaires sp√©cialis√©s pour g√©n√©rer les structures de donn√©es calendaires, calculer les positions des √©v√©nements et g√©rer les chevauchements d'affichage.

üõ†Ô∏è **Type de fichier :** `.ts` (utilitaires)

üîÑ **Comportement attendu :**
Cr√©er le fichier `src/modules/calendar-module/utils/calendar-utils.ts` :

```typescript
import { 
  startOfMonth, 
  endOfMonth, 
  startOfWeek, 
  endOfWeek,
  eachDayOfInterval,
  eachWeekOfInterval,
  format,
  isSameDay,
  isSameMonth,
  isToday,
  isWeekend,
  addDays,
  differenceInDays,
  parseISO,
  isAfter,
  isBefore
} from 'date-fns';
import { fr } from 'date-fns/locale';
import { 
  CalendarEvent, 
  CalendarMonth, 
  CalendarDay, 
  CalendarWeek 
} from '../types/calendar';

export class CalendarUtils {
  // G√©n√©ration d'un mois calendaire complet
  static generateCalendarMonth(date: Date, events: CalendarEvent[]): CalendarMonth {
    const monthStart = startOfMonth(date);
    const monthEnd = endOfMonth(date);
    const calendarStart = startOfWeek(monthStart, { weekStartsOn: 1 }); // Lundi
    const calendarEnd = endOfWeek(monthEnd, { weekStartsOn: 1 });

    // G√©n√©ration de tous les jours du calendrier
    const allDays = eachDayOfInterval({
      start: calendarStart,
      end: calendarEnd
    });

    // Transformation en CalendarDay avec √©v√©nements
    const calendarDays = allDays.map(day => {
      const dayEvents = this.getEventsForDay(day, events);
      
      return {
        date: day,
        is_current_month: isSameMonth(day, date),
        is_today: isToday(day),
        is_weekend: isWeekend(day),
        events: dayEvents,
        event_count: dayEvents.length
      };
    });

    // G√©n√©ration des semaines
    const weeks = eachWeekOfInterval({
      start: calendarStart,
      end: calendarEnd
    }, { weekStartsOn: 1 }).map((weekStart, index) => {
      const weekDays = calendarDays.slice(index * 7, (index + 1) * 7);
      
      return {
        week_number: parseInt(format(weekStart, 'w', { locale: fr })),
        days: weekDays
      };
    });

    return {
      year: date.getFullYear(),
      month: date.getMonth(),
      days: calendarDays,
      weeks
    };
  }

  // R√©cup√©ration des √©v√©nements pour un jour donn√©
  static getEventsForDay(date: Date, events: CalendarEvent[]): CalendarEvent[] {
    return events.filter(event => {
      const eventStart = parseISO(event.start_date);
      const eventEnd = parseISO(event.end_date);
      
      // V√©rifier si le jour est dans la plage de l'√©v√©nement
      return (
        isSameDay(date, eventStart) ||
        isSameDay(date, eventEnd) ||
        (isAfter(date, eventStart) && isBefore(date, eventEnd))
      );
    });
  }

  // Calcul de la position d'un √©v√©nement dans le calendrier
  static calculateEventPosition(
    event: CalendarEvent, 
    monthStart: Date
  ): { 
    startOffset: number; 
    duration: number; 
    row: number 
  } {
    const eventStart = parseISO(event.start_date);
    const eventEnd = parseISO(event.end_date);
    
    // Calcul de l'offset depuis le d√©but du mois
    const startOffset = Math.max(0, differenceInDays(eventStart, monthStart));
    
    // Calcul de la dur√©e en jours
    const duration = Math.max(1, differenceInDays(eventEnd, eventStart) + 1);
    
    // Calcul de la ligne (pour √©viter les chevauchements)
    const row = this.calculateEventRow(event, monthStart);
    
    return { startOffset, duration, row };
  }

  // Calcul de la ligne d'affichage pour √©viter les chevauchements
  private static calculateEventRow(event: CalendarEvent, monthStart: Date): number {
    // Logique simplifi√©e - peut √™tre am√©lior√©e avec un algorithme plus sophistiqu√©
    const eventStart = parseISO(event.start_date);
    const dayOfMonth = differenceInDays(eventStart, monthStart);
    
    // Utilise le hash de l'ID pour une distribution pseudo-al√©atoire
    const hash = this.simpleHash(event.id);
    return hash % 3; // Maximum 3 lignes par jour
  }

  // Hash simple pour la distribution des √©v√©nements
  private static simpleHash(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash);
  }

  // G√©n√©ration d'une grille d'√©v√©nements pour l'affichage
  static generateEventGrid(
    events: CalendarEvent[], 
    monthStart: Date, 
    monthEnd: Date
  ): Map<string, CalendarEvent[]> {
    const grid = new Map<string, CalendarEvent[]>();
    
    // G√©n√©ration de toutes les dates du mois
    const allDates = eachDayOfInterval({ start: monthStart, end: monthEnd });
    
    allDates.forEach(date => {
      const dateKey = format(date, 'yyyy-MM-dd');
      const dayEvents = this.getEventsForDay(date, events);
      
      // Tri des √©v√©nements par heure de d√©but
      dayEvents.sort((a, b) => {
        const timeA = parseISO(a.start_date).getTime();
        const timeB = parseISO(b.start_date).getTime();
        return timeA - timeB;
      });
      
      grid.set(dateKey, dayEvents);
    });
    
    return grid;
  }

  // Formatage des dates pour l'affichage
  static formatDateForDisplay(date: Date | string, formatStr: string = 'dd/MM/yyyy'): string {
    const dateObj = typeof date === 'string' ? parseISO(date) : date;
    return format(dateObj, formatStr, { locale: fr });
  }

  // Formatage des heures pour l'affichage
  static formatTimeForDisplay(date: Date | string): string {
    const dateObj = typeof date === 'string' ? parseISO(date) : date;
    return format(dateObj, 'HH:mm', { locale: fr });
  }

  // Calcul de la dur√©e d'un √©v√©nement
  static calculateEventDuration(startDate: string, endDate: string): {
    days: number;
    hours: number;
    minutes: number;
    formatted: string;
  } {
    const start = parseISO(startDate);
    const end = parseISO(endDate);
    
    const totalMinutes = differenceInDays(end, start) * 24 * 60 + 
                        (end.getHours() - start.getHours()) * 60 + 
                        (end.getMinutes() - start.getMinutes());
    
    const days = Math.floor(totalMinutes / (24 * 60));
    const hours = Math.floor((totalMinutes % (24 * 60)) / 60);
    const minutes = totalMinutes % 60;
    
    let formatted = '';
    if (days > 0) formatted += `${days}j `;
    if (hours > 0) formatted += `${hours}h `;
    if (minutes > 0) formatted += `${minutes}min`;
    
    return { days, hours, minutes, formatted: formatted.trim() };
  }

  // D√©tection des conflits d'√©v√©nements
  static detectEventConflicts(events: CalendarEvent[]): Map<string, string[]> {
    const conflicts = new Map<string, string[]>();
    
    for (let i = 0; i < events.length; i++) {
      for (let j = i + 1; j < events.length; j++) {
        const event1 = events[i];
        const event2 = events[j];
        
        if (this.eventsOverlap(event1, event2)) {
          // Ajouter le conflit pour event1
          if (!conflicts.has(event1.id)) {
            conflicts.set(event1.id, []);
          }
          conflicts.get(event1.id)!.push(event2.id);
          
          // Ajouter le conflit pour event2
          if (!conflicts.has(event2.id)) {
            conflicts.set(event2.id, []);
          }
          conflicts.get(event2.id)!.push(event1.id);
        }
      }
    }
    
    return conflicts;
  }

  // V√©rification du chevauchement entre deux √©v√©nements
  static eventsOverlap(event1: CalendarEvent, event2: CalendarEvent): boolean {
    const start1 = parseISO(event1.start_date);
    const end1 = parseISO(event1.end_date);
    const start2 = parseISO(event2.start_date);
    const end2 = parseISO(event2.end_date);
    
    return start1 < end2 && start2 < end1;
  }

  // G√©n√©ration des options de navigation rapide
  static generateQuickNavigationOptions(currentDate: Date): Array<{
    label: string;
    date: Date;
    isCurrent: boolean;
  }> {
    const options = [];
    const currentYear = currentDate.getFullYear();
    
    // Mois de l'ann√©e courante
    for (let month = 0; month < 12; month++) {
      const date = new Date(currentYear, month, 1);
      options.push({
        label: format(date, 'MMMM yyyy', { locale: fr }),
        date,
        isCurrent: isSameMonth(date, currentDate)
      });
    }
    
    return options;
  }

  // Calcul des statistiques d'occupation
  static calculateOccupancyStats(
    events: CalendarEvent[], 
    venues: Array<{ id: string; name: string }>,
    startDate: Date,
    endDate: Date
  ): {
    totalDays: number;
    occupiedDays: number;
    occupancyRate: number;
    venueStats: Array<{
      venueId: string;
      venueName: string;
      eventCount: number;
      occupiedDays: number;
      occupancyRate: number;
    }>;
  } {
    const totalDays = differenceInDays(endDate, startDate) + 1;
    const occupiedDaysSet = new Set<string>();
    
    // Calcul global
    events.forEach(event => {
      const eventStart = parseISO(event.start_date);
      const eventEnd = parseISO(event.end_date);
      
      const eventDays = eachDayOfInterval({ start: eventStart, end: eventEnd });
      eventDays.forEach(day => {
        if (day >= startDate && day <= endDate) {
          occupiedDaysSet.add(format(day, 'yyyy-MM-dd'));
        }
      });
    });
    
    const occupiedDays = occupiedDaysSet.size;
    const occupancyRate = totalDays > 0 ? (occupiedDays / totalDays) * 100 : 0;
    
    // Calcul par lieu
    const venueStats = venues.map(venue => {
      const venueEvents = events.filter(event => event.venue_id === venue.id);
      const venueOccupiedDaysSet = new Set<string>();
      
      venueEvents.forEach(event => {
        const eventStart = parseISO(event.start_date);
        const eventEnd = parseISO(event.end_date);
        
        const eventDays = eachDayOfInterval({ start: eventStart, end: eventEnd });
        eventDays.forEach(day => {
          if (day >= startDate && day <= endDate) {
            venueOccupiedDaysSet.add(format(day, 'yyyy-MM-dd'));
          }
        });
      });
      
      const venueOccupiedDays = venueOccupiedDaysSet.size;
      const venueOccupancyRate = totalDays > 0 ? (venueOccupiedDays / totalDays) * 100 : 0;
      
      return {
        venueId: venue.id,
        venueName: venue.name,
        eventCount: venueEvents.length,
        occupiedDays: venueOccupiedDays,
        occupancyRate: venueOccupancyRate
      };
    });
    
    return {
      totalDays,
      occupiedDays,
      occupancyRate,
      venueStats
    };
  }
}

// Export des utilitaires
export const {
  generateCalendarMonth,
  getEventsForDay,
  calculateEventPosition,
  generateEventGrid,
  formatDateForDisplay,
  formatTimeForDisplay,
  calculateEventDuration,
  detectEventConflicts,
  eventsOverlap,
  generateQuickNavigationOptions,
  calculateOccupancyStats
} = CalendarUtils;
```

‚öôÔ∏è **Interactions :** 
- Utilise date-fns pour les manipulations de dates
- Int√®gre avec les types CalendarEvent et CalendarMonth
- Optimis√© pour les calculs de positionnement et de chevauchement

üí° **Tips Windsurf :** Utilise des Map et Set pour les performances. Impl√©mente des algorithmes de cache pour les calculs co√ªteux. Teste avec des volumes importants d'√©v√©nements.

---

### 06 - Configuration du contexte React et providers

üéØ **But :** Cr√©er le contexte React global pour le module Calendrier avec gestion d'√©tat centralis√©e et optimisations de performance.

üß† **Contexte technique :** Le contexte React centralise l'√©tat du calendrier et fournit une API coh√©rente pour tous les composants enfants. Il int√®gre les hooks personnalis√©s et optimise les re-rendus avec des s√©lecteurs granulaires.

üõ†Ô∏è **Type de fichier :** `.tsx` (contexte React)

üîÑ **Comportement attendu :**
Cr√©er le fichier `src/modules/calendar-module/contexts/CalendarContext.tsx` :

```typescript
import React, { 
  createContext, 
  useContext, 
  ReactNode, 
  useMemo,
  useCallback 
} from 'react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useCalendar } from '../hooks/use-calendar';
import { 
  CalendarEvent, 
  CalendarVenue, 
  CalendarStats, 
  CalendarFilters,
  CalendarViewOptions,
  CalendarEventClick,
  CalendarDateClick
} from '../types/calendar';

// Interface du contexte
interface CalendarContextType {
  // Navigation
  currentDate: Date;
  currentMonth: {
    start: Date;
    end: Date;
    label: string;
    year: number;
    month: number;
  };
  goToPreviousMonth: () => void;
  goToNextMonth: () => void;
  goToToday: () => void;
  goToDate: (date: Date) => void;
  isCurrentMonth: boolean;

  // Donn√©es
  events: CalendarEvent[];
  venues: CalendarVenue[];
  stats: CalendarStats | null;

  // √âtats de chargement
  isLoadingEvents: boolean;
  isLoadingVenues: boolean;
  isLoadingStats: boolean;
  isLoading: boolean;

  // Erreurs
  eventsError: Error | null;
  venuesError: Error | null;
  statsError: Error | null;
  hasErrors: boolean;

  // Filtres
  filters: CalendarFilters;
  updateVenueFilter: (venueIds: string[]) => void;
  updateStatusFilter: (statuses: string[]) => void;
  clearFilters: () => void;
  hasActiveFilters: boolean;

  // Options d'affichage
  viewOptions: CalendarViewOptions;
  updateViewType: (viewType: 'month' | 'week' | 'day') => void;
  toggleWeekends: () => void;
  togglePastEvents: () => void;
  toggleCompactMode: () => void;

  // Documents
  getDocumentUrl: (path: string) => Promise<string>;
  isDocumentLoading: (path: string) => boolean;

  // Actions
  refetchEvents: () => void;
  refetchAll: () => void;

  // √âv√©nements UI
  onEventClick?: (event: CalendarEventClick) => void;
  onDateClick?: (event: CalendarDateClick) => void;
  selectedEvent: CalendarEvent | null;
  setSelectedEvent: (event: CalendarEvent | null) => void;
}

// Cr√©ation du contexte
const CalendarContext = createContext<CalendarContextType | null>(null);

// Props du provider
interface CalendarProviderProps {
  children: ReactNode;
  onEventClick?: (event: CalendarEventClick) => void;
  onDateClick?: (event: CalendarDateClick) => void;
  initialDate?: Date;
  queryClient?: QueryClient;
}

// Configuration du QueryClient pour le calendrier
const createCalendarQueryClient = () => {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 2 * 60 * 1000, // 2 minutes
        cacheTime: 5 * 60 * 1000, // 5 minutes
        refetchOnWindowFocus: false,
        retry: (failureCount, error) => {
          // Retry logic personnalis√©e
          if (failureCount < 2) return true;
          return false;
        }
      }
    }
  });
};

// Provider principal
export function CalendarProvider({ 
  children, 
  onEventClick,
  onDateClick,
  initialDate,
  queryClient 
}: CalendarProviderProps) {
  // QueryClient pour les requ√™tes
  const calendarQueryClient = useMemo(() => {
    return queryClient || createCalendarQueryClient();
  }, [queryClient]);

  return (
    <QueryClientProvider client={calendarQueryClient}>
      <CalendarProviderInner
        onEventClick={onEventClick}
        onDateClick={onDateClick}
        initialDate={initialDate}
      >
        {children}
      </CalendarProviderInner>
    </QueryClientProvider>
  );
}

// Provider interne avec la logique m√©tier
function CalendarProviderInner({ 
  children, 
  onEventClick,
  onDateClick,
  initialDate 
}: Omit<CalendarProviderProps, 'queryClient'>) {
  // √âtat principal du calendrier
  const calendar = useCalendar();
  
  // √âtat local pour l'√©v√©nement s√©lectionn√©
  const [selectedEvent, setSelectedEvent] = React.useState<CalendarEvent | null>(null);

  // Calculs d√©riv√©s optimis√©s
  const isLoading = useMemo(() => {
    return calendar.isLoadingEvents || calendar.isLoadingVenues || calendar.isLoadingStats;
  }, [calendar.isLoadingEvents, calendar.isLoadingVenues, calendar.isLoadingStats]);

  const hasErrors = useMemo(() => {
    return !!(calendar.eventsError || calendar.venuesError || calendar.statsError);
  }, [calendar.eventsError, calendar.venuesError, calendar.statsError]);

  // Action de rechargement global
  const refetchAll = useCallback(() => {
    calendar.refetchEvents();
    // Les autres donn√©es se rechargent automatiquement via les d√©pendances
  }, [calendar.refetchEvents]);

  // Gestionnaire d'√©v√©nement optimis√©
  const handleEventClick = useCallback((event: CalendarEvent, position: { x: number; y: number }) => {
    const eventClick: CalendarEventClick = {
      event,
      date: new Date(event.start_date),
      position
    };
    
    setSelectedEvent(event);
    onEventClick?.(eventClick);
  }, [onEventClick]);

  // Gestionnaire de clic sur date optimis√©
  const handleDateClick = useCallback((date: Date, events: CalendarEvent[]) => {
    const dateClick: CalendarDateClick = {
      date,
      has_events: events.length > 0,
      events
    };
    
    onDateClick?.(dateClick);
  }, [onDateClick]);

  // Valeur du contexte optimis√©e
  const contextValue = useMemo<CalendarContextType>(() => ({
    // Navigation
    currentDate: calendar.currentDate,
    currentMonth: calendar.currentMonth,
    goToPreviousMonth: calendar.goToPreviousMonth,
    goToNextMonth: calendar.goToNextMonth,
    goToToday: calendar.goToToday,
    goToDate: calendar.goToDate,
    isCurrentMonth: calendar.isCurrentMonth,

    // Donn√©es
    events: calendar.events,
    venues: calendar.venues,
    stats: calendar.stats,

    // √âtats de chargement
    isLoadingEvents: calendar.isLoadingEvents,
    isLoadingVenues: calendar.isLoadingVenues,
    isLoadingStats: calendar.isLoadingStats,
    isLoading,

    // Erreurs
    eventsError: calendar.eventsError,
    venuesError: calendar.venuesError,
    statsError: calendar.statsError,
    hasErrors,

    // Filtres
    filters: calendar.filters,
    updateVenueFilter: calendar.updateVenueFilter,
    updateStatusFilter: calendar.updateStatusFilter,
    clearFilters: calendar.clearFilters,
    hasActiveFilters: calendar.hasActiveFilters,

    // Options d'affichage
    viewOptions: calendar.viewOptions,
    updateViewType: calendar.updateViewType,
    toggleWeekends: calendar.toggleWeekends,
    togglePastEvents: calendar.togglePastEvents,
    toggleCompactMode: calendar.toggleCompactMode,

    // Documents
    getDocumentUrl: calendar.getDocumentUrl,
    isDocumentLoading: calendar.isDocumentLoading,

    // Actions
    refetchEvents: calendar.refetchEvents,
    refetchAll,

    // √âv√©nements UI
    onEventClick: handleEventClick,
    onDateClick: handleDateClick,
    selectedEvent,
    setSelectedEvent
  }), [
    calendar,
    isLoading,
    hasErrors,
    refetchAll,
    handleEventClick,
    handleDateClick,
    selectedEvent
  ]);

  return (
    <CalendarContext.Provider value={contextValue}>
      {children}
    </CalendarContext.Provider>
  );
}

// Hook pour utiliser le contexte
export function useCalendarContext(): CalendarContextType {
  const context = useContext(CalendarContext);
  
  if (!context) {
    throw new Error('useCalendarContext doit √™tre utilis√© dans un CalendarProvider');
  }
  
  return context;
}

// Hooks s√©lecteurs pour optimiser les re-rendus
export function useCalendarNavigation() {
  const context = useCalendarContext();
  
  return useMemo(() => ({
    currentDate: context.currentDate,
    currentMonth: context.currentMonth,
    goToPreviousMonth: context.goToPreviousMonth,
    goToNextMonth: context.goToNextMonth,
    goToToday: context.goToToday,
    goToDate: context.goToDate,
    isCurrentMonth: context.isCurrentMonth
  }), [
    context.currentDate,
    context.currentMonth,
    context.goToPreviousMonth,
    context.goToNextMonth,
    context.goToToday,
    context.goToDate,
    context.isCurrentMonth
  ]);
}

export function useCalendarData() {
  const context = useCalendarContext();
  
  return useMemo(() => ({
    events: context.events,
    venues: context.venues,
    stats: context.stats,
    isLoading: context.isLoading,
    hasErrors: context.hasErrors,
    refetchAll: context.refetchAll
  }), [
    context.events,
    context.venues,
    context.stats,
    context.isLoading,
    context.hasErrors,
    context.refetchAll
  ]);
}

export function useCalendarFilters() {
  const context = useCalendarContext();
  
  return useMemo(() => ({
    filters: context.filters,
    updateVenueFilter: context.updateVenueFilter,
    updateStatusFilter: context.updateStatusFilter,
    clearFilters: context.clearFilters,
    hasActiveFilters: context.hasActiveFilters
  }), [
    context.filters,
    context.updateVenueFilter,
    context.updateStatusFilter,
    context.clearFilters,
    context.hasActiveFilters
  ]);
}

export function useCalendarViewOptions() {
  const context = useCalendarContext();
  
  return useMemo(() => ({
    viewOptions: context.viewOptions,
    updateViewType: context.updateViewType,
    toggleWeekends: context.toggleWeekends,
    togglePastEvents: context.togglePastEvents,
    toggleCompactMode: context.toggleCompactMode
  }), [
    context.viewOptions,
    context.updateViewType,
    context.toggleWeekends,
    context.togglePastEvents,
    context.toggleCompactMode
  ]);
}

// HOC pour injecter le contexte
export function withCalendarContext<P extends object>(
  Component: React.ComponentType<P>
) {
  return function CalendarContextComponent(props: P) {
    return (
      <CalendarProvider>
        <Component {...props} />
      </CalendarProvider>
    );
  };
}

// Export du contexte pour les tests
export { CalendarContext };
```

‚öôÔ∏è **Interactions :** 
- Utilise les hooks personnalis√©s cr√©√©s dans le prompt 04
- Int√®gre TanStack Query pour la gestion des requ√™tes
- Optimise les re-rendus avec des s√©lecteurs granulaires

üí° **Tips Windsurf :** Utilise React.memo pour les composants enfants. Impl√©mente des s√©lecteurs granulaires pour √©viter les re-rendus inutiles. Teste les performances avec React DevTools Profiler.

---


## üèóÔ∏è Section 2 : Fonctionnalit√©s Principales

### 07 - Cr√©ation de la page principale du calendrier

üéØ **But :** D√©velopper la page principale du module Calendrier avec layout responsive, navigation temporelle et int√©gration dans la sidebar du Backoffice.

üß† **Contexte technique :** La page principale constitue l'interface centrale du module Calendrier. Elle doit s'int√©grer parfaitement dans la navigation du Backoffice et fournir une exp√©rience utilisateur optimale avec chargement progressif et gestion d'erreurs.

üõ†Ô∏è **Type de fichier :** `.tsx` (page Next.js)

üîÑ **Comportement attendu :**
Cr√©er le fichier `src/app/(backoffice)/calendrier/page.tsx` :

```typescript
import { Metadata } from 'next';
import { Suspense } from 'react';
import { CalendarProvider } from '@/modules/calendar-module/contexts/CalendarContext';
import { CalendarLayout } from '@/modules/calendar-module/components/CalendarLayout';
import { CalendarSkeleton } from '@/modules/calendar-module/components/CalendarSkeleton';
import { ErrorBoundary } from '@/components/ui/error-boundary';
import { PageHeader } from '@/components/ui/page-header';
import { Calendar, Filter, BarChart3 } from 'lucide-react';

export const metadata: Metadata = {
  title: 'Calendrier - Wedding Collection',
  description: 'Vue calendaire de tous les √©v√©nements et disponibilit√©s'
};

export default function CalendrierPage() {
  return (
    <div className="flex flex-col h-full">
      {/* En-t√™te de page */}
      <PageHeader
        title="Calendrier"
        description="Vue d'ensemble de tous les √©v√©nements et disponibilit√©s"
        icon={Calendar}
        actions={[
          {
            label: 'Filtres',
            icon: Filter,
            variant: 'outline',
            onClick: () => {
              // Sera g√©r√© par le composant CalendarLayout
            }
          },
          {
            label: 'Statistiques',
            icon: BarChart3,
            variant: 'outline',
            onClick: () => {
              // Sera g√©r√© par le composant CalendarLayout
            }
          }
        ]}
      />

      {/* Contenu principal avec gestion d'erreurs */}
      <div className="flex-1 overflow-hidden">
        <ErrorBoundary
          fallback={
            <div className="flex items-center justify-center h-full">
              <div className="text-center">
                <Calendar className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
                <h3 className="text-lg font-semibold mb-2">
                  Erreur de chargement du calendrier
                </h3>
                <p className="text-muted-foreground mb-4">
                  Une erreur est survenue lors du chargement du calendrier.
                </p>
                <button 
                  onClick={() => window.location.reload()}
                  className="px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90"
                >
                  Recharger la page
                </button>
              </div>
            </div>
          }
        >
          <CalendarProvider
            onEventClick={(event) => {
              console.log('√âv√©nement cliqu√©:', event);
              // Navigation vers le d√©tail de l'√©v√©nement
              // window.open(`/backoffice/evenements/${event.event.id}`, '_blank');
            }}
            onDateClick={(dateEvent) => {
              console.log('Date cliqu√©e:', dateEvent);
              // Affichage des √©v√©nements du jour ou cr√©ation d'un nouvel √©v√©nement
            }}
          >
            <Suspense fallback={<CalendarSkeleton />}>
              <CalendarLayout />
            </Suspense>
          </CalendarProvider>
        </ErrorBoundary>
      </div>
    </div>
  );
}
```

Cr√©er √©galement le fichier `src/modules/calendar-module/components/CalendarSkeleton.tsx` :

```typescript
import { Skeleton } from '@/components/ui/skeleton';
import { Card, CardContent, CardHeader } from '@/components/ui/card';

export function CalendarSkeleton() {
  return (
    <div className="p-6 space-y-6">
      {/* Barre d'outils */}
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-4">
          <Skeleton className="h-10 w-32" />
          <Skeleton className="h-10 w-24" />
          <Skeleton className="h-10 w-24" />
        </div>
        <div className="flex items-center space-x-2">
          <Skeleton className="h-10 w-10" />
          <Skeleton className="h-10 w-10" />
          <Skeleton className="h-10 w-10" />
        </div>
      </div>

      {/* Filtres */}
      <Card>
        <CardHeader>
          <Skeleton className="h-6 w-24" />
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <Skeleton className="h-10 w-full" />
            <Skeleton className="h-10 w-full" />
            <Skeleton className="h-10 w-full" />
          </div>
        </CardContent>
      </Card>

      {/* Calendrier */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <Skeleton className="h-8 w-48" />
            <div className="flex space-x-2">
              <Skeleton className="h-8 w-8" />
              <Skeleton className="h-8 w-8" />
            </div>
          </div>
        </CardHeader>
        <CardContent>
          {/* En-t√™tes des jours */}
          <div className="grid grid-cols-7 gap-1 mb-2">
            {Array.from({ length: 7 }).map((_, i) => (
              <Skeleton key={i} className="h-8 w-full" />
            ))}
          </div>
          
          {/* Grille du calendrier */}
          <div className="grid grid-cols-7 gap-1">
            {Array.from({ length: 35 }).map((_, i) => (
              <div key={i} className="aspect-square">
                <Skeleton className="h-full w-full" />
              </div>
            ))}
          </div>
        </CardContent>
      </Card>

      {/* Statistiques */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        {Array.from({ length: 4 }).map((_, i) => (
          <Card key={i}>
            <CardContent className="p-6">
              <div className="flex items-center space-x-2">
                <Skeleton className="h-8 w-8" />
                <div className="space-y-1">
                  <Skeleton className="h-4 w-16" />
                  <Skeleton className="h-6 w-12" />
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );
}
```

‚öôÔ∏è **Interactions :** 
- S'int√®gre dans la navigation du Backoffice via la sidebar
- Utilise le CalendarProvider pour la gestion d'√©tat
- Gestion d'erreurs avec ErrorBoundary et fallbacks

üí° **Tips Windsurf :** Utilise Suspense pour le chargement progressif. Impl√©mente des skeletons d√©taill√©s pour une meilleure UX. Teste la navigation entre modules.

---

### 08 - D√©veloppement du composant CalendarLayout principal

üéØ **But :** Cr√©er le composant CalendarLayout qui orchestre l'affichage du calendrier avec barre d'outils, filtres et vue calendaire.

üß† **Contexte technique :** Le CalendarLayout est le composant principal qui organise l'interface du calendrier. Il g√®re la disposition responsive, l'√©tat des filtres et coordonne les interactions entre les diff√©rents sous-composants.

üõ†Ô∏è **Type de fichier :** `.tsx` (composant React)

üîÑ **Comportement attendu :**
Cr√©er le fichier `src/modules/calendar-module/components/CalendarLayout.tsx` :

```typescript
import { useState } from 'react';
import { useCalendarContext } from '../contexts/CalendarContext';
import { CalendarToolbar } from './CalendarToolbar';
import { CalendarFilters } from './CalendarFilters';
import { CalendarGrid } from './CalendarGrid';
import { CalendarStats } from './CalendarStats';
import { EventDetailsModal } from './EventDetailsModal';
import { Card } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Loader2, AlertCircle } from 'lucide-react';
import { cn } from '@/lib/utils';

export function CalendarLayout() {
  const {
    isLoading,
    hasErrors,
    eventsError,
    venuesError,
    statsError,
    selectedEvent,
    setSelectedEvent,
    viewOptions
  } = useCalendarContext();

  const [showFilters, setShowFilters] = useState(false);
  const [showStats, setShowStats] = useState(false);

  // Gestion des erreurs
  if (hasErrors) {
    return (
      <div className="p-6">
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>
            {eventsError?.message || 
             venuesError?.message || 
             statsError?.message || 
             'Une erreur est survenue lors du chargement du calendrier.'}
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full">
      {/* Barre d'outils */}
      <div className="border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <CalendarToolbar
          onToggleFilters={() => setShowFilters(!showFilters)}
          onToggleStats={() => setShowStats(!showStats)}
          showFilters={showFilters}
          showStats={showStats}
        />
      </div>

      {/* Contenu principal */}
      <div className="flex-1 overflow-hidden">
        <div className="h-full flex flex-col lg:flex-row">
          {/* Panneau lat√©ral gauche - Filtres */}
          <div className={cn(
            "lg:w-80 border-r bg-muted/30 transition-all duration-300",
            showFilters ? "block" : "hidden lg:block",
            viewOptions.compact_mode && "lg:w-64"
          )}>
            <div className="h-full overflow-y-auto">
              <CalendarFilters />
            </div>
          </div>

          {/* Zone principale du calendrier */}
          <div className="flex-1 flex flex-col overflow-hidden">
            {/* Indicateur de chargement global */}
            {isLoading && (
              <div className="absolute top-4 right-4 z-50">
                <div className="flex items-center space-x-2 bg-background border rounded-md px-3 py-2 shadow-md">
                  <Loader2 className="h-4 w-4 animate-spin" />
                  <span className="text-sm text-muted-foreground">
                    Chargement...
                  </span>
                </div>
              </div>
            )}

            {/* Grille du calendrier */}
            <div className="flex-1 overflow-hidden">
              <CalendarGrid />
            </div>

            {/* Panneau des statistiques */}
            {showStats && (
              <div className="border-t bg-muted/30">
                <CalendarStats />
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Modal de d√©tails d'√©v√©nement */}
      {selectedEvent && (
        <EventDetailsModal
          event={selectedEvent}
          isOpen={!!selectedEvent}
          onClose={() => setSelectedEvent(null)}
        />
      )}
    </div>
  );
}
```

‚öôÔ∏è **Interactions :** 
- Utilise le CalendarContext pour l'√©tat global
- Coordonne les composants CalendarToolbar, CalendarFilters, CalendarGrid
- G√®re l'affichage responsive et les panneaux lat√©raux

üí° **Tips Windsurf :** Utilise des transitions CSS pour les animations. Impl√©mente un syst√®me de layout responsive avec Tailwind. Optimise les re-rendus avec React.memo.

---

### 09 - Cr√©ation de la barre d'outils de navigation

üéØ **But :** D√©velopper le composant CalendarToolbar avec navigation temporelle, s√©lecteurs de vue et actions rapides.

üß† **Contexte technique :** La barre d'outils fournit les contr√¥les principaux du calendrier : navigation entre les mois, s√©lection du type de vue, acc√®s aux filtres et statistiques. Elle doit √™tre intuitive et responsive.

üõ†Ô∏è **Type de fichier :** `.tsx` (composant React)

üîÑ **Comportement attendu :**
Cr√©er le fichier `src/modules/calendar-module/components/CalendarToolbar.tsx` :

```typescript
import { useState } from 'react';
import { useCalendarNavigation, useCalendarViewOptions } from '../contexts/CalendarContext';
import { Button } from '@/components/ui/button';
import { 
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue 
} from '@/components/ui/select';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator
} from '@/components/ui/dropdown-menu';
import { Badge } from '@/components/ui/badge';
import { 
  ChevronLeft, 
  ChevronRight, 
  Calendar,
  Filter,
  BarChart3,
  Settings,
  Download,
  RefreshCw,
  Grid3X3,
  List,
  Eye,
  EyeOff
} from 'lucide-react';
import { format, addMonths, subMonths } from 'date-fns';
import { fr } from 'date-fns/locale';
import { cn } from '@/lib/utils';

interface CalendarToolbarProps {
  onToggleFilters: () => void;
  onToggleStats: () => void;
  showFilters: boolean;
  showStats: boolean;
}

export function CalendarToolbar({
  onToggleFilters,
  onToggleStats,
  showFilters,
  showStats
}: CalendarToolbarProps) {
  const {
    currentDate,
    currentMonth,
    goToPreviousMonth,
    goToNextMonth,
    goToToday,
    goToDate,
    isCurrentMonth
  } = useCalendarNavigation();

  const {
    viewOptions,
    updateViewType,
    toggleWeekends,
    togglePastEvents,
    toggleCompactMode
  } = useCalendarViewOptions();

  const [showQuickNav, setShowQuickNav] = useState(false);

  // G√©n√©ration des options de navigation rapide
  const quickNavOptions = Array.from({ length: 12 }, (_, i) => {
    const date = addMonths(new Date(), i - 6);
    return {
      date,
      label: format(date, 'MMMM yyyy', { locale: fr }),
      isCurrent: format(date, 'yyyy-MM') === format(currentDate, 'yyyy-MM')
    };
  });

  return (
    <div className="px-6 py-4">
      <div className="flex items-center justify-between">
        {/* Navigation temporelle */}
        <div className="flex items-center space-x-4">
          {/* Contr√¥les de navigation */}
          <div className="flex items-center space-x-1">
            <Button
              variant="outline"
              size="sm"
              onClick={goToPreviousMonth}
              className="h-9 w-9 p-0"
            >
              <ChevronLeft className="h-4 w-4" />
            </Button>

            {/* S√©lecteur de mois/ann√©e */}
            <DropdownMenu open={showQuickNav} onOpenChange={setShowQuickNav}>
              <DropdownMenuTrigger asChild>
                <Button
                  variant="ghost"
                  className="h-9 px-3 font-semibold min-w-[140px] justify-start"
                >
                  <Calendar className="h-4 w-4 mr-2" />
                  {currentMonth.label}
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="start" className="w-48">
                {quickNavOptions.map((option) => (
                  <DropdownMenuItem
                    key={option.label}
                    onClick={() => {
                      goToDate(option.date);
                      setShowQuickNav(false);
                    }}
                    className={cn(
                      option.isCurrent && "bg-accent font-medium"
                    )}
                  >
                    {option.label}
                  </DropdownMenuItem>
                ))}
              </DropdownMenuContent>
            </DropdownMenu>

            <Button
              variant="outline"
              size="sm"
              onClick={goToNextMonth}
              className="h-9 w-9 p-0"
            >
              <ChevronRight className="h-4 w-4" />
            </Button>
          </div>

          {/* Bouton Aujourd'hui */}
          <Button
            variant={isCurrentMonth ? "secondary" : "outline"}
            size="sm"
            onClick={goToToday}
            disabled={isCurrentMonth}
          >
            Aujourd'hui
          </Button>

          {/* S√©lecteur de type de vue */}
          <Select
            value={viewOptions.view_type}
            onValueChange={(value: 'month' | 'week' | 'day') => updateViewType(value)}
          >
            <SelectTrigger className="w-32 h-9">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="month">Mois</SelectItem>
              <SelectItem value="week">Semaine</SelectItem>
              <SelectItem value="day">Jour</SelectItem>
            </SelectContent>
          </Select>
        </div>

        {/* Actions et options */}
        <div className="flex items-center space-x-2">
          {/* Options d'affichage */}
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" size="sm" className="h-9">
                <Settings className="h-4 w-4 mr-2" />
                Options
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className="w-56">
              <DropdownMenuItem onClick={toggleWeekends}>
                <div className="flex items-center justify-between w-full">
                  <span>Afficher les week-ends</span>
                  {viewOptions.show_weekends ? (
                    <Eye className="h-4 w-4" />
                  ) : (
                    <EyeOff className="h-4 w-4" />
                  )}
                </div>
              </DropdownMenuItem>
              
              <DropdownMenuItem onClick={togglePastEvents}>
                <div className="flex items-center justify-between w-full">
                  <span>√âv√©nements pass√©s</span>
                  {viewOptions.show_past_events ? (
                    <Eye className="h-4 w-4" />
                  ) : (
                    <EyeOff className="h-4 w-4" />
                  )}
                </div>
              </DropdownMenuItem>

              <DropdownMenuItem onClick={toggleCompactMode}>
                <div className="flex items-center justify-between w-full">
                  <span>Mode compact</span>
                  {viewOptions.compact_mode ? (
                    <List className="h-4 w-4" />
                  ) : (
                    <Grid3X3 className="h-4 w-4" />
                  )}
                </div>
              </DropdownMenuItem>

              <DropdownMenuSeparator />

              <DropdownMenuItem>
                <Download className="h-4 w-4 mr-2" />
                Exporter le calendrier
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>

          {/* Bouton Filtres */}
          <Button
            variant={showFilters ? "secondary" : "outline"}
            size="sm"
            onClick={onToggleFilters}
            className="h-9"
          >
            <Filter className="h-4 w-4 mr-2" />
            Filtres
          </Button>

          {/* Bouton Statistiques */}
          <Button
            variant={showStats ? "secondary" : "outline"}
            size="sm"
            onClick={onToggleStats}
            className="h-9"
          >
            <BarChart3 className="h-4 w-4 mr-2" />
            Stats
          </Button>

          {/* Bouton Actualiser */}
          <Button
            variant="outline"
            size="sm"
            onClick={() => window.location.reload()}
            className="h-9 w-9 p-0"
          >
            <RefreshCw className="h-4 w-4" />
          </Button>
        </div>
      </div>

      {/* Indicateurs d'√©tat */}
      <div className="flex items-center justify-between mt-3">
        <div className="flex items-center space-x-2">
          {/* Badges d'options actives */}
          {!viewOptions.show_weekends && (
            <Badge variant="secondary" className="text-xs">
              Sans week-ends
            </Badge>
          )}
          {!viewOptions.show_past_events && (
            <Badge variant="secondary" className="text-xs">
              Sans √©v√©nements pass√©s
            </Badge>
          )}
          {viewOptions.compact_mode && (
            <Badge variant="secondary" className="text-xs">
              Mode compact
            </Badge>
          )}
        </div>

        {/* Raccourcis clavier */}
        <div className="hidden md:flex items-center space-x-4 text-xs text-muted-foreground">
          <span>‚Üê ‚Üí Navigation</span>
          <span>T Aujourd'hui</span>
          <span>F Filtres</span>
        </div>
      </div>
    </div>
  );
}
```

‚öôÔ∏è **Interactions :** 
- Utilise les hooks de navigation et d'options d'affichage du contexte
- Int√®gre avec les composants UI de ShadCN
- G√®re les raccourcis clavier et la navigation rapide

üí° **Tips Windsurf :** Impl√©mente les raccourcis clavier avec useEffect et addEventListener. Utilise des transitions pour les changements d'√©tat. Teste l'accessibilit√© avec les lecteurs d'√©cran.

---

### 10 - D√©veloppement du panneau de filtres

üéØ **But :** Cr√©er le composant CalendarFilters avec s√©lection de lieux, statuts et options de filtrage avanc√©es.

üß† **Contexte technique :** Le panneau de filtres permet aux utilisateurs de personnaliser l'affichage du calendrier selon leurs besoins. Il doit √™tre intuitif, responsive et fournir un feedback visuel sur les filtres actifs.

üõ†Ô∏è **Type de fichier :** `.tsx` (composant React)

üîÑ **Comportement attendu :**
Cr√©er le fichier `src/modules/calendar-module/components/CalendarFilters.tsx` :

```typescript
import { useState, useMemo } from 'react';
import { useCalendarFilters, useCalendarData } from '../contexts/CalendarContext';
import { EVENT_STATUS_CONFIG } from '../types/calendar';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Checkbox } from '@/components/ui/checkbox';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Separator } from '@/components/ui/separator';
import { 
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger 
} from '@/components/ui/collapsible';
import { 
  MapPin, 
  Calendar,
  X,
  ChevronDown,
  Search,
  Filter,
  RotateCcw
} from 'lucide-react';
import { cn } from '@/lib/utils';

export function CalendarFilters() {
  const {
    filters,
    updateVenueFilter,
    updateStatusFilter,
    clearFilters,
    hasActiveFilters
  } = useCalendarFilters();

  const { venues, isLoading } = useCalendarData();

  const [searchVenue, setSearchVenue] = useState('');
  const [venuesExpanded, setVenuesExpanded] = useState(true);
  const [statusExpanded, setStatusExpanded] = useState(true);

  // Filtrage des lieux par recherche
  const filteredVenues = useMemo(() => {
    if (!searchVenue) return venues;
    return venues.filter(venue =>
      venue.name.toLowerCase().includes(searchVenue.toLowerCase())
    );
  }, [venues, searchVenue]);

  // Gestion de la s√©lection des lieux
  const handleVenueToggle = (venueId: string) => {
    const newVenueIds = filters.venue_ids.includes(venueId)
      ? filters.venue_ids.filter(id => id !== venueId)
      : [...filters.venue_ids, venueId];
    
    updateVenueFilter(newVenueIds);
  };

  const handleVenueSelectAll = () => {
    const allVenueIds = filteredVenues.map(venue => venue.id);
    updateVenueFilter(allVenueIds);
  };

  const handleVenueDeselectAll = () => {
    updateVenueFilter([]);
  };

  // Gestion de la s√©lection des statuts
  const handleStatusToggle = (status: string) => {
    const newStatuses = filters.statuses.includes(status)
      ? filters.statuses.filter(s => s !== status)
      : [...filters.statuses, status];
    
    updateStatusFilter(newStatuses);
  };

  const handleStatusSelectAll = () => {
    const allStatuses = Object.keys(EVENT_STATUS_CONFIG);
    updateStatusFilter(allStatuses);
  };

  const handleStatusDeselectAll = () => {
    updateStatusFilter([]);
  };

  return (
    <div className="p-4 space-y-4">
      {/* En-t√™te avec actions */}
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-2">
          <Filter className="h-5 w-5 text-muted-foreground" />
          <h3 className="font-semibold">Filtres</h3>
          {hasActiveFilters && (
            <Badge variant="secondary" className="text-xs">
              {filters.venue_ids.length + filters.statuses.length}
            </Badge>
          )}
        </div>
        
        {hasActiveFilters && (
          <Button
            variant="ghost"
            size="sm"
            onClick={clearFilters}
            className="h-8 px-2"
          >
            <RotateCcw className="h-4 w-4 mr-1" />
            Effacer
          </Button>
        )}
      </div>

      {/* Filtres actifs */}
      {hasActiveFilters && (
        <Card className="bg-muted/50">
          <CardContent className="p-3">
            <div className="space-y-2">
              <Label className="text-xs font-medium text-muted-foreground">
                Filtres actifs
              </Label>
              <div className="flex flex-wrap gap-1">
                {/* Badges des lieux s√©lectionn√©s */}
                {filters.venue_ids.map(venueId => {
                  const venue = venues.find(v => v.id === venueId);
                  if (!venue) return null;
                  
                  return (
                    <Badge
                      key={venueId}
                      variant="secondary"
                      className="text-xs"
                    >
                      <MapPin className="h-3 w-3 mr-1" />
                      {venue.name}
                      <button
                        onClick={() => handleVenueToggle(venueId)}
                        className="ml-1 hover:bg-muted-foreground/20 rounded-full p-0.5"
                      >
                        <X className="h-2 w-2" />
                      </button>
                    </Badge>
                  );
                })}
                
                {/* Badges des statuts s√©lectionn√©s */}
                {filters.statuses.map(status => {
                  const statusConfig = EVENT_STATUS_CONFIG[status as keyof typeof EVENT_STATUS_CONFIG];
                  if (!statusConfig) return null;
                  
                  return (
                    <Badge
                      key={status}
                      variant="secondary"
                      className="text-xs"
                      style={{ 
                        backgroundColor: statusConfig.bg_color,
                        color: statusConfig.text_color 
                      }}
                    >
                      <Calendar className="h-3 w-3 mr-1" />
                      {statusConfig.label}
                      <button
                        onClick={() => handleStatusToggle(status)}
                        className="ml-1 hover:bg-muted-foreground/20 rounded-full p-0.5"
                      >
                        <X className="h-2 w-2" />
                      </button>
                    </Badge>
                  );
                })}
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Filtre par lieux */}
      <Card>
        <Collapsible open={venuesExpanded} onOpenChange={setVenuesExpanded}>
          <CollapsibleTrigger asChild>
            <CardHeader className="pb-3 cursor-pointer hover:bg-muted/50 transition-colors">
              <CardTitle className="flex items-center justify-between text-sm">
                <div className="flex items-center space-x-2">
                  <MapPin className="h-4 w-4" />
                  <span>Lieux</span>
                  {filters.venue_ids.length > 0 && (
                    <Badge variant="secondary" className="text-xs">
                      {filters.venue_ids.length}
                    </Badge>
                  )}
                </div>
                <ChevronDown className={cn(
                  "h-4 w-4 transition-transform",
                  venuesExpanded && "rotate-180"
                )} />
              </CardTitle>
            </CardHeader>
          </CollapsibleTrigger>
          
          <CollapsibleContent>
            <CardContent className="pt-0 space-y-3">
              {/* Recherche de lieux */}
              <div className="relative">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  placeholder="Rechercher un lieu..."
                  value={searchVenue}
                  onChange={(e) => setSearchVenue(e.target.value)}
                  className="pl-9 h-9"
                />
              </div>

              {/* Actions de s√©lection */}
              <div className="flex space-x-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleVenueSelectAll}
                  className="h-7 text-xs"
                  disabled={isLoading}
                >
                  Tout s√©lectionner
                </Button>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleVenueDeselectAll}
                  className="h-7 text-xs"
                  disabled={filters.venue_ids.length === 0}
                >
                  Tout d√©s√©lectionner
                </Button>
              </div>

              <Separator />

              {/* Liste des lieux */}
              <div className="space-y-2 max-h-64 overflow-y-auto">
                {isLoading ? (
                  <div className="text-center py-4 text-sm text-muted-foreground">
                    Chargement des lieux...
                  </div>
                ) : filteredVenues.length === 0 ? (
                  <div className="text-center py-4 text-sm text-muted-foreground">
                    {searchVenue ? 'Aucun lieu trouv√©' : 'Aucun lieu disponible'}
                  </div>
                ) : (
                  filteredVenues.map(venue => (
                    <div
                      key={venue.id}
                      className="flex items-center space-x-3 p-2 rounded-md hover:bg-muted/50 transition-colors"
                    >
                      <Checkbox
                        id={`venue-${venue.id}`}
                        checked={filters.venue_ids.includes(venue.id)}
                        onCheckedChange={() => handleVenueToggle(venue.id)}
                      />
                      <Label
                        htmlFor={`venue-${venue.id}`}
                        className="flex-1 cursor-pointer text-sm"
                      >
                        <div className="flex items-center justify-between">
                          <span>{venue.name}</span>
                          {venue.event_count > 0 && (
                            <Badge variant="outline" className="text-xs">
                              {venue.event_count}
                            </Badge>
                          )}
                        </div>
                      </Label>
                    </div>
                  ))
                )}
              </div>
            </CardContent>
          </CollapsibleContent>
        </Collapsible>
      </Card>

      {/* Filtre par statuts */}
      <Card>
        <Collapsible open={statusExpanded} onOpenChange={setStatusExpanded}>
          <CollapsibleTrigger asChild>
            <CardHeader className="pb-3 cursor-pointer hover:bg-muted/50 transition-colors">
              <CardTitle className="flex items-center justify-between text-sm">
                <div className="flex items-center space-x-2">
                  <Calendar className="h-4 w-4" />
                  <span>Statuts</span>
                  {filters.statuses.length > 0 && (
                    <Badge variant="secondary" className="text-xs">
                      {filters.statuses.length}
                    </Badge>
                  )}
                </div>
                <ChevronDown className={cn(
                  "h-4 w-4 transition-transform",
                  statusExpanded && "rotate-180"
                )} />
              </CardTitle>
            </CardHeader>
          </CollapsibleTrigger>
          
          <CollapsibleContent>
            <CardContent className="pt-0 space-y-3">
              {/* Actions de s√©lection */}
              <div className="flex space-x-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleStatusSelectAll}
                  className="h-7 text-xs"
                >
                  Tout s√©lectionner
                </Button>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleStatusDeselectAll}
                  className="h-7 text-xs"
                  disabled={filters.statuses.length === 0}
                >
                  Tout d√©s√©lectionner
                </Button>
              </div>

              <Separator />

              {/* Liste des statuts */}
              <div className="space-y-2">
                {Object.entries(EVENT_STATUS_CONFIG).map(([status, config]) => (
                  <div
                    key={status}
                    className="flex items-center space-x-3 p-2 rounded-md hover:bg-muted/50 transition-colors"
                  >
                    <Checkbox
                      id={`status-${status}`}
                      checked={filters.statuses.includes(status)}
                      onCheckedChange={() => handleStatusToggle(status)}
                    />
                    <Label
                      htmlFor={`status-${status}`}
                      className="flex-1 cursor-pointer text-sm"
                    >
                      <div className="flex items-center space-x-2">
                        <div
                          className="w-3 h-3 rounded-full"
                          style={{ backgroundColor: config.color }}
                        />
                        <span>{config.label}</span>
                      </div>
                    </Label>
                  </div>
                ))}
              </div>
            </CardContent>
          </CollapsibleContent>
        </Collapsible>
      </Card>
    </div>
  );
}
```

‚öôÔ∏è **Interactions :** 
- Utilise les hooks de filtres et de donn√©es du contexte
- Int√®gre avec les composants UI de ShadCN pour la coh√©rence
- G√®re la recherche et la s√©lection multiple avec feedback visuel

üí° **Tips Windsurf :** Impl√©mente un debounce pour la recherche de lieux. Utilise des animations pour les transitions d'√©tat. Optimise les re-rendus avec useMemo et useCallback.

---

### 11 - Cr√©ation de la grille calendaire principale

üéØ **But :** D√©velopper le composant CalendarGrid qui affiche la grille calendaire avec √©v√©nements, gestion des interactions et responsive design.

üß† **Contexte technique :** La grille calendaire est le composant central qui affiche les jours du mois avec les √©v√©nements associ√©s. Elle doit g√©rer les interactions utilisateur, l'affichage responsive et les optimisations de performance pour de gros volumes d'√©v√©nements.

üõ†Ô∏è **Type de fichier :** `.tsx` (composant React)

üîÑ **Comportement attendu :**
Cr√©er le fichier `src/modules/calendar-module/components/CalendarGrid.tsx` :

```typescript
import { useMemo, useCallback } from 'react';
import { useCalendarContext } from '../contexts/CalendarContext';
import { CalendarUtils } from '../utils/calendar-utils';
import { CalendarDay } from './CalendarDay';
import { CalendarEvent } from './CalendarEvent';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { 
  ChevronLeft, 
  ChevronRight,
  Calendar as CalendarIcon,
  Clock
} from 'lucide-react';
import { format, isSameMonth, isToday, isWeekend } from 'date-fns';
import { fr } from 'date-fns/locale';
import { cn } from '@/lib/utils';

const DAYS_OF_WEEK = [
  'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'
];

export function CalendarGrid() {
  const {
    currentDate,
    currentMonth,
    events,
    goToPreviousMonth,
    goToNextMonth,
    viewOptions,
    onEventClick,
    onDateClick,
    isLoadingEvents
  } = useCalendarContext();

  // G√©n√©ration du mois calendaire avec √©v√©nements
  const calendarMonth = useMemo(() => {
    return CalendarUtils.generateCalendarMonth(currentDate, events);
  }, [currentDate, events]);

  // Filtrage des jours selon les options d'affichage
  const filteredDays = useMemo(() => {
    return calendarMonth.days.filter(day => {
      // Filtrer les week-ends si n√©cessaire
      if (!viewOptions.show_weekends && isWeekend(day.date)) {
        return false;
      }
      
      // Filtrer les √©v√©nements pass√©s si n√©cessaire
      if (!viewOptions.show_past_events && day.date < new Date()) {
        return false;
      }
      
      return true;
    });
  }, [calendarMonth.days, viewOptions]);

  // Gestion du clic sur un √©v√©nement
  const handleEventClick = useCallback((event: any, position: { x: number; y: number }) => {
    onEventClick?.({
      event,
      date: new Date(event.start_date),
      position
    });
  }, [onEventClick]);

  // Gestion du clic sur une date
  const handleDateClick = useCallback((date: Date, dayEvents: any[]) => {
    onDateClick?.({
      date,
      has_events: dayEvents.length > 0,
      events: dayEvents
    });
  }, [onDateClick]);

  // Calcul des colonnes de la grille
  const gridCols = viewOptions.show_weekends ? 'grid-cols-7' : 'grid-cols-5';

  return (
    <Card className="h-full flex flex-col">
      {/* En-t√™te du calendrier */}
      <CardHeader className="pb-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4">
            <div className="flex items-center space-x-2">
              <CalendarIcon className="h-5 w-5 text-muted-foreground" />
              <h2 className="text-xl font-semibold">
                {currentMonth.label}
              </h2>
            </div>
            
            {/* Indicateur de chargement */}
            {isLoadingEvents && (
              <Badge variant="secondary" className="animate-pulse">
                <Clock className="h-3 w-3 mr-1" />
                Chargement...
              </Badge>
            )}
          </div>

          {/* Navigation rapide */}
          <div className="flex items-center space-x-1">
            <Button
              variant="ghost"
              size="sm"
              onClick={goToPreviousMonth}
              className="h-8 w-8 p-0"
            >
              <ChevronLeft className="h-4 w-4" />
            </Button>
            <Button
              variant="ghost"
              size="sm"
              onClick={goToNextMonth}
              className="h-8 w-8 p-0"
            >
              <ChevronRight className="h-4 w-4" />
            </Button>
          </div>
        </div>

        {/* Statistiques rapides */}
        <div className="flex items-center space-x-4 text-sm text-muted-foreground">
          <span>{events.length} √©v√©nement(s) ce mois</span>
          <span>‚Ä¢</span>
          <span>
            {calendarMonth.days.filter(day => day.event_count > 0).length} jour(s) occup√©(s)
          </span>
        </div>
      </CardHeader>

      {/* Grille du calendrier */}
      <CardContent className="flex-1 overflow-hidden p-0">
        <div className="h-full flex flex-col">
          {/* En-t√™tes des jours de la semaine */}
          <div className={cn(
            "grid border-b bg-muted/30",
            gridCols
          )}>
            {DAYS_OF_WEEK.map((day, index) => {
              // Masquer les week-ends si n√©cessaire
              if (!viewOptions.show_weekends && (index === 5 || index === 6)) {
                return null;
              }
              
              return (
                <div
                  key={day}
                  className="p-3 text-center text-sm font-medium text-muted-foreground border-r last:border-r-0"
                >
                  <span className="hidden sm:inline">{day}</span>
                  <span className="sm:hidden">{day.slice(0, 3)}</span>
                </div>
              );
            })}
          </div>

          {/* Grille des jours */}
          <div className="flex-1 overflow-y-auto">
            <div className={cn(
              "grid auto-rows-fr min-h-full",
              gridCols
            )}>
              {calendarMonth.weeks.map((week) =>
                week.days.map((day) => {
                  // Masquer les week-ends si n√©cessaire
                  if (!viewOptions.show_weekends && isWeekend(day.date)) {
                    return null;
                  }

                  return (
                    <CalendarDay
                      key={day.date.toISOString()}
                      day={day}
                      currentMonth={currentDate}
                      compactMode={viewOptions.compact_mode}
                      onEventClick={handleEventClick}
                      onDateClick={handleDateClick}
                    />
                  );
                })
              )}
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
```

Cr√©er √©galement le fichier `src/modules/calendar-module/components/CalendarDay.tsx` :

```typescript
import { useMemo } from 'react';
import { CalendarEvent } from './CalendarEvent';
import { CalendarDay as CalendarDayType } from '../types/calendar';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Plus } from 'lucide-react';
import { format, isSameMonth, isToday } from 'date-fns';
import { fr } from 'date-fns/locale';
import { cn } from '@/lib/utils';

interface CalendarDayProps {
  day: CalendarDayType;
  currentMonth: Date;
  compactMode: boolean;
  onEventClick: (event: any, position: { x: number; y: number }) => void;
  onDateClick: (date: Date, events: any[]) => void;
}

export function CalendarDay({
  day,
  currentMonth,
  compactMode,
  onEventClick,
  onDateClick
}: CalendarDayProps) {
  // Tri des √©v√©nements par heure de d√©but
  const sortedEvents = useMemo(() => {
    return [...day.events].sort((a, b) => {
      return new Date(a.start_date).getTime() - new Date(b.start_date).getTime();
    });
  }, [day.events]);

  // Limitation du nombre d'√©v√©nements affich√©s
  const maxEvents = compactMode ? 2 : 3;
  const visibleEvents = sortedEvents.slice(0, maxEvents);
  const hiddenEventsCount = Math.max(0, sortedEvents.length - maxEvents);

  const handleDateClick = () => {
    onDateClick(day.date, day.events);
  };

  const handleEventClick = (event: any, e: React.MouseEvent) => {
    e.stopPropagation();
    const rect = e.currentTarget.getBoundingClientRect();
    onEventClick(event, {
      x: rect.left + rect.width / 2,
      y: rect.top
    });
  };

  return (
    <div
      className={cn(
        "border-r border-b last:border-r-0 min-h-[120px] p-2 cursor-pointer transition-colors",
        "hover:bg-muted/50",
        !day.is_current_month && "bg-muted/20 text-muted-foreground",
        day.is_today && "bg-primary/5 border-primary/20",
        compactMode && "min-h-[80px] p-1"
      )}
      onClick={handleDateClick}
    >
      {/* En-t√™te du jour */}
      <div className="flex items-center justify-between mb-2">
        <span className={cn(
          "text-sm font-medium",
          day.is_today && "text-primary font-semibold",
          !day.is_current_month && "text-muted-foreground",
          compactMode && "text-xs"
        )}>
          {format(day.date, 'd')}
        </span>

        {/* Indicateur d'√©v√©nements multiples */}
        {day.event_count > 0 && (
          <Badge 
            variant={day.is_today ? "default" : "secondary"} 
            className={cn(
              "text-xs h-5 px-1.5",
              compactMode && "h-4 px-1 text-[10px]"
            )}
          >
            {day.event_count}
          </Badge>
        )}
      </div>

      {/* Liste des √©v√©nements */}
      <div className="space-y-1">
        {visibleEvents.map((event, index) => (
          <CalendarEvent
            key={`${event.id}-${index}`}
            event={event}
            compactMode={compactMode}
            onClick={(e) => handleEventClick(event, e)}
          />
        ))}

        {/* Indicateur d'√©v√©nements cach√©s */}
        {hiddenEventsCount > 0 && (
          <Button
            variant="ghost"
            size="sm"
            className={cn(
              "w-full h-6 text-xs text-muted-foreground hover:text-foreground",
              compactMode && "h-5 text-[10px]"
            )}
            onClick={(e) => {
              e.stopPropagation();
              handleDateClick();
            }}
          >
            <Plus className="h-3 w-3 mr-1" />
            {hiddenEventsCount} de plus
          </Button>
        )}
      </div>

      {/* Zone de cr√©ation rapide d'√©v√©nement */}
      {day.event_count === 0 && day.is_current_month && (
        <div className="flex-1 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity">
          <Button
            variant="ghost"
            size="sm"
            className={cn(
              "h-8 w-8 p-0 text-muted-foreground hover:text-foreground",
              compactMode && "h-6 w-6"
            )}
            onClick={(e) => {
              e.stopPropagation();
              handleDateClick();
            }}
          >
            <Plus className="h-4 w-4" />
          </Button>
        </div>
      )}
    </div>
  );
}
```

‚öôÔ∏è **Interactions :** 
- Utilise le contexte calendaire pour les donn√©es et interactions
- Int√®gre avec les composants CalendarDay et CalendarEvent
- G√®re les options d'affichage et le responsive design

üí° **Tips Windsurf :** Utilise la virtualisation pour de gros volumes d'√©v√©nements. Impl√©mente le lazy loading pour les mois adjacents. Optimise les calculs avec useMemo et useCallback.

---

### 12 - D√©veloppement du composant d'√©v√©nement calendaire

üéØ **But :** Cr√©er le composant CalendarEvent pour l'affichage des √©v√©nements dans la grille avec informations essentielles et interactions.

üß† **Contexte technique :** Le composant CalendarEvent affiche les informations essentielles d'un √©v√©nement dans l'espace restreint d'une cellule calendaire. Il doit √™tre informatif, interactif et s'adapter aux diff√©rents modes d'affichage.

üõ†Ô∏è **Type de fichier :** `.tsx` (composant React)

üîÑ **Comportement attendu :**
Cr√©er le fichier `src/modules/calendar-module/components/CalendarEvent.tsx` :

```typescript
import { useMemo } from 'react';
import { CalendarEvent as CalendarEventType } from '../types/calendar';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { 
  Clock, 
  MapPin, 
  User,
  FileText,
  AlertCircle
} from 'lucide-react';
import { format, parseISO, isSameDay } from 'date-fns';
import { fr } from 'date-fns/locale';
import { cn } from '@/lib/utils';

interface CalendarEventProps {
  event: CalendarEventType;
  compactMode: boolean;
  onClick: (e: React.MouseEvent) => void;
}

export function CalendarEvent({ event, compactMode, onClick }: CalendarEventProps) {
  // Calcul des informations d'affichage
  const eventInfo = useMemo(() => {
    const startDate = parseISO(event.start_date);
    const endDate = parseISO(event.end_date);
    const isMultiDay = event.is_multi_day;
    const isSingleDay = isSameDay(startDate, endDate);

    // Formatage de l'heure
    let timeDisplay = '';
    if (isSingleDay) {
      timeDisplay = format(startDate, 'HH:mm', { locale: fr });
      if (startDate.getTime() !== endDate.getTime()) {
        timeDisplay += ` - ${format(endDate, 'HH:mm', { locale: fr })}`;
      }
    } else {
      timeDisplay = `${format(startDate, 'dd/MM', { locale: fr })} - ${format(endDate, 'dd/MM', { locale: fr })}`;
    }

    // Titre tronqu√©
    const maxTitleLength = compactMode ? 15 : 25;
    const truncatedTitle = event.name.length > maxTitleLength 
      ? `${event.name.substring(0, maxTitleLength)}...`
      : event.name;

    // Client tronqu√©
    const maxClientLength = compactMode ? 10 : 15;
    const truncatedClient = event.client_name && event.client_name.length > maxClientLength
      ? `${event.client_name.substring(0, maxClientLength)}...`
      : event.client_name;

    return {
      timeDisplay,
      truncatedTitle,
      truncatedClient,
      isMultiDay,
      isSingleDay
    };
  }, [event, compactMode]);

  // D√©termination de la couleur et du style
  const eventStyle = useMemo(() => {
    const baseClasses = "text-left transition-all duration-200 hover:scale-[1.02] hover:shadow-sm";
    
    // Couleur bas√©e sur le statut ou couleur personnalis√©e
    const backgroundColor = event.metadata?.color_override || event.display_color;
    const isLightColor = isColorLight(backgroundColor);
    
    return {
      backgroundColor,
      color: isLightColor ? '#000000' : '#ffffff',
      borderColor: darkenColor(backgroundColor, 20),
      className: cn(
        baseClasses,
        compactMode ? "text-xs p-1 rounded" : "text-sm p-2 rounded-md",
        "border border-opacity-50"
      )
    };
  }, [event, compactMode]);

  // Indicateurs d'√©tat
  const hasDocuments = event.document_urls && Object.keys(event.document_urls).length > 0;
  const hasSpecialRequirements = event.metadata?.special_requirements;
  const isHighPriority = event.metadata?.priority === 'high';

  return (
    <Button
      variant="ghost"
      className={cn(
        eventStyle.className,
        "w-full h-auto justify-start p-0 hover:bg-transparent"
      )}
      style={{
        backgroundColor: eventStyle.backgroundColor,
        color: eventStyle.color,
        borderColor: eventStyle.borderColor
      }}
      onClick={onClick}
    >
      <div className="w-full space-y-1">
        {/* Ligne principale : Heure et titre */}
        <div className="flex items-start justify-between">
          <div className="flex-1 min-w-0">
            {/* Titre de l'√©v√©nement */}
            <div className={cn(
              "font-medium truncate",
              compactMode ? "text-xs" : "text-sm"
            )}>
              {eventInfo.truncatedTitle}
            </div>
            
            {/* Heure */}
            <div className={cn(
              "flex items-center opacity-90",
              compactMode ? "text-[10px]" : "text-xs"
            )}>
              <Clock className={cn(
                "mr-1 flex-shrink-0",
                compactMode ? "h-2.5 w-2.5" : "h-3 w-3"
              )} />
              {eventInfo.timeDisplay}
            </div>
          </div>

          {/* Indicateurs d'√©tat */}
          <div className="flex items-center space-x-1 ml-1">
            {isHighPriority && (
              <AlertCircle className={cn(
                "text-red-500",
                compactMode ? "h-2.5 w-2.5" : "h-3 w-3"
              )} />
            )}
            {hasDocuments && (
              <FileText className={cn(
                "opacity-70",
                compactMode ? "h-2.5 w-2.5" : "h-3 w-3"
              )} />
            )}
          </div>
        </div>

        {/* Ligne secondaire : Client et lieu (mode normal uniquement) */}
        {!compactMode && (
          <div className="space-y-0.5">
            {/* Client */}
            {eventInfo.truncatedClient && (
              <div className="flex items-center text-xs opacity-90">
                <User className="h-2.5 w-2.5 mr-1 flex-shrink-0" />
                <span className="truncate">{eventInfo.truncatedClient}</span>
              </div>
            )}
            
            {/* Lieu */}
            {event.venue_name && (
              <div className="flex items-center text-xs opacity-90">
                <MapPin className="h-2.5 w-2.5 mr-1 flex-shrink-0" />
                <span className="truncate">{event.venue_name}</span>
              </div>
            )}
          </div>
        )}

        {/* Abr√©viation (mode compact uniquement) */}
        {compactMode && event.abbreviation && (
          <div className="text-right">
            <Badge 
              variant="secondary" 
              className="text-[8px] h-3 px-1"
              style={{
                backgroundColor: 'rgba(255,255,255,0.2)',
                color: eventStyle.color
              }}
            >
              {event.abbreviation}
            </Badge>
          </div>
        )}

        {/* Indicateur multi-jours */}
        {eventInfo.isMultiDay && (
          <div className="flex justify-end">
            <Badge 
              variant="secondary" 
              className={cn(
                "text-[8px] h-3 px-1",
                compactMode ? "text-[7px] h-2.5 px-0.5" : ""
              )}
              style={{
                backgroundColor: 'rgba(255,255,255,0.2)',
                color: eventStyle.color
              }}
            >
              {event.duration_days}j
            </Badge>
          </div>
        )}
      </div>
    </Button>
  );
}

// Utilitaires de couleur
function isColorLight(color: string): boolean {
  // Conversion hex vers RGB
  const hex = color.replace('#', '');
  const r = parseInt(hex.substr(0, 2), 16);
  const g = parseInt(hex.substr(2, 2), 16);
  const b = parseInt(hex.substr(4, 2), 16);
  
  // Calcul de la luminance
  const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
  return luminance > 0.5;
}

function darkenColor(color: string, percent: number): string {
  const hex = color.replace('#', '');
  const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - Math.round(255 * percent / 100));
  const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - Math.round(255 * percent / 100));
  const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - Math.round(255 * percent / 100));
  
  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}
```

‚öôÔ∏è **Interactions :** 
- Affiche les informations essentielles de l'√©v√©nement
- S'adapte au mode compact et normal
- G√®re les interactions de clic avec propagation d'√©v√©nements

üí° **Tips Windsurf :** Utilise des couleurs contrast√©es pour l'accessibilit√©. Impl√©mente des tooltips pour les informations tronqu√©es. Teste avec diff√©rentes longueurs de texte.

---


## üîß Section 3 : Fonctionnalit√©s Secondaires

### 13 - D√©veloppement du panneau de statistiques

üéØ **But :** Cr√©er le composant CalendarStats avec m√©triques de performance, indicateurs de charge et analytics temporels.

üß† **Contexte technique :** Le panneau de statistiques fournit une vue d'ensemble des m√©triques calendaires importantes. Il doit afficher des donn√©es en temps r√©el, √™tre responsive et offrir des insights utiles pour la planification.

üõ†Ô∏è **Type de fichier :** `.tsx` (composant React)

üîÑ **Comportement attendu :**
Cr√©er le fichier `src/modules/calendar-module/components/CalendarStats.tsx` avec m√©triques de performance, graphiques de charge et indicateurs de disponibilit√©.

‚öôÔ∏è **Interactions :** 
- Utilise les donn√©es du contexte calendaire
- Int√®gre avec les composants de graphiques (Recharts)
- Affiche des m√©triques en temps r√©el

üí° **Tips Windsurf :** Utilise React Query pour le cache des statistiques. Impl√©mente des graphiques responsives avec Recharts. Optimise les calculs avec des workers si n√©cessaire.

---

### 14 - Cr√©ation de la modal de d√©tails d'√©v√©nement

üéØ **But :** D√©velopper le composant EventDetailsModal pour l'affichage d√©taill√© des √©v√©nements avec actions rapides.

üß† **Contexte technique :** La modal de d√©tails permet de consulter et modifier rapidement les informations d'un √©v√©nement depuis le calendrier. Elle doit √™tre performante, accessible et offrir les actions essentielles.

üõ†Ô∏è **Type de fichier :** `.tsx` (composant React)

üîÑ **Comportement attendu :**
Cr√©er le fichier `src/modules/calendar-module/components/EventDetailsModal.tsx` avec affichage complet des d√©tails, actions rapides et navigation vers le module √âv√©nement.

‚öôÔ∏è **Interactions :** 
- Affiche les d√©tails complets de l'√©v√©nement s√©lectionn√©
- Fournit des actions rapides (√©dition, suppression, duplication)
- Permet la navigation vers le module √âv√©nement pour √©dition compl√®te

üí° **Tips Windsurf :** Utilise des animations fluides pour l'ouverture/fermeture. Impl√©mente le lazy loading pour les donn√©es d√©taill√©es. G√®re l'accessibilit√© avec focus management.

---

### 15 - Impl√©mentation de la synchronisation calendriers externes

üéØ **But :** D√©velopper le syst√®me de synchronisation avec Google Calendar, Outlook et autres calendriers externes.

üß† **Contexte technique :** La synchronisation permet d'importer/exporter les √©v√©nements vers les calendriers personnels des utilisateurs. Elle doit g√©rer l'authentification OAuth, la synchronisation bidirectionnelle et la r√©solution de conflits.

üõ†Ô∏è **Type de fichier :** `.ts` (services et hooks)

üîÑ **Comportement attendu :**
Cr√©er les services de synchronisation dans `src/modules/calendar-module/services/` avec gestion OAuth, import/export et synchronisation temps r√©el.

‚öôÔ∏è **Interactions :** 
- Int√®gre avec les APIs Google Calendar et Microsoft Graph
- G√®re l'authentification et les tokens de refresh
- Synchronise les √©v√©nements bidirectionnellement

üí° **Tips Windsurf :** Utilise des Edge Functions pour les webhooks. Impl√©mente un syst√®me de queue pour les synchronisations. G√®re les erreurs de r√©seau avec retry automatique.

---

### 16 - D√©veloppement des vues alternatives (semaine/jour)

üéØ **But :** Cr√©er les composants CalendarWeekView et CalendarDayView pour les vues d√©taill√©es.

üß† **Contexte technique :** Les vues semaine et jour offrent une granularit√© plus fine pour la planification. Elles doivent afficher les cr√©neaux horaires, g√©rer les conflits et permettre la cr√©ation d'√©v√©nements par glisser-d√©poser.

üõ†Ô∏è **Type de fichier :** `.tsx` (composants React)

üîÑ **Comportement attendu :**
Cr√©er les composants `CalendarWeekView.tsx` et `CalendarDayView.tsx` avec grilles horaires, gestion des conflits et interactions avanc√©es.

‚öôÔ∏è **Interactions :** 
- Affiche les cr√©neaux horaires avec pr√©cision
- G√®re les √©v√©nements qui se chevauchent
- Permet la cr√©ation et modification par glisser-d√©poser

üí° **Tips Windsurf :** Utilise react-dnd pour le drag & drop. Impl√©mente la virtualisation pour les longues journ√©es. Optimise le rendu avec React.memo.

---

### 17 - Cr√©ation du syst√®me de notifications calendaires

üéØ **But :** D√©velopper le syst√®me de notifications pour rappels, conflits et mises √† jour d'√©v√©nements.

üß† **Contexte technique :** Le syst√®me de notifications informe les utilisateurs des √©v√©nements importants, conflits de planning et modifications. Il doit √™tre configurable, non-intrusif et int√©gr√© avec les notifications syst√®me.

üõ†Ô∏è **Type de fichier :** `.ts` et `.tsx` (services et composants)

üîÑ **Comportement attendu :**
Cr√©er le syst√®me de notifications dans `src/modules/calendar-module/notifications/` avec gestion des rappels, d√©tection de conflits et notifications push.

‚öôÔ∏è **Interactions :** 
- Int√®gre avec l'API Notifications du navigateur
- Utilise Supabase Realtime pour les mises √† jour
- G√®re les pr√©f√©rences utilisateur

üí° **Tips Windsurf :** Utilise Service Workers pour les notifications hors-ligne. Impl√©mente un syst√®me de priorit√©s. Respecte les pr√©f√©rences utilisateur.

---

### 18 - Impl√©mentation de l'export et impression

üéØ **But :** D√©velopper les fonctionnalit√©s d'export PDF, impression et partage du calendrier.

üß† **Contexte technique :** Les fonctionnalit√©s d'export permettent de partager et archiver les plannings. Elles doivent g√©n√©rer des documents de qualit√© professionnelle avec mise en forme adapt√©e.

üõ†Ô∏è **Type de fichier :** `.ts` (services d'export)

üîÑ **Comportement attendu :**
Cr√©er les services d'export dans `src/modules/calendar-module/export/` avec g√©n√©ration PDF, export iCal et impression optimis√©e.

‚öôÔ∏è **Interactions :** 
- G√©n√®re des PDFs avec jsPDF ou Puppeteer
- Exporte au format iCal pour compatibilit√©
- Optimise la mise en page pour l'impression

üí° **Tips Windsurf :** Utilise des templates pour la mise en forme. Impl√©mente la g√©n√©ration c√¥t√© serveur pour les gros volumes. G√®re les polices et images.

---

## üöÄ Section 4 : √âvolutions Futures

### 19 - Intelligence artificielle pour optimisation de planning

üéØ **But :** Int√©grer l'IA pour suggestions de cr√©neaux, d√©tection de conflits et optimisation automatique des plannings.

üß† **Contexte technique :** L'IA analyse les patterns de planification pour proposer des optimisations intelligentes. Elle doit apprendre des pr√©f√©rences utilisateur et sugg√©rer des am√©liorations proactives.

üõ†Ô∏è **Type de fichier :** `.ts` (services IA)

üîÑ **Comportement attendu :**
D√©velopper les services IA dans `src/modules/calendar-module/ai/` avec algorithmes d'optimisation, machine learning et suggestions intelligentes.

‚öôÔ∏è **Interactions :** 
- Int√®gre avec la Console IA Automatisation
- Utilise des mod√®les de ML pour les pr√©dictions
- Fournit des suggestions contextuelles

üí° **Tips Windsurf :** Utilise TensorFlow.js pour le ML c√¥t√© client. Impl√©mente des algorithmes g√©n√©tiques pour l'optimisation. Collecte les feedbacks utilisateur.

---

### 20 - Int√©gration avec syst√®mes de r√©servation externes

üéØ **But :** Connecter le calendrier avec les syst√®mes de r√©servation de lieux et prestataires externes.

üß† **Contexte technique :** L'int√©gration permet de synchroniser automatiquement les disponibilit√©s et r√©servations avec les syst√®mes tiers. Elle doit g√©rer les APIs diverses et maintenir la coh√©rence des donn√©es.

üõ†Ô∏è **Type de fichier :** `.ts` (connecteurs et adaptateurs)

üîÑ **Comportement attendu :**
Cr√©er les connecteurs dans `src/modules/calendar-module/integrations/` avec adaptateurs pour diff√©rentes APIs, synchronisation temps r√©el et gestion des erreurs.

‚öôÔ∏è **Interactions :** 
- Connecte avec les APIs de r√©servation populaires
- Synchronise les disponibilit√©s bidirectionnellement
- G√®re les webhooks et notifications

üí° **Tips Windsurf :** Utilise des adaptateurs pour standardiser les APIs. Impl√©mente un syst√®me de retry robuste. G√®re les rate limits et quotas.

---

### 21 - Calendrier collaboratif temps r√©el

üéØ **But :** D√©velopper les fonctionnalit√©s de collaboration temps r√©el avec √©dition simultan√©e et synchronisation instantan√©e.

üß† **Contexte technique :** La collaboration temps r√©el permet √† plusieurs utilisateurs de modifier le calendrier simultan√©ment. Elle doit g√©rer les conflits, maintenir la coh√©rence et fournir un feedback visuel.

üõ†Ô∏è **Type de fichier :** `.tsx` et `.ts` (composants et services)

üîÑ **Comportement attendu :**
Impl√©menter la collaboration dans `src/modules/calendar-module/collaboration/` avec operational transforms, curseurs multiples et r√©solution de conflits.

‚öôÔ∏è **Interactions :** 
- Utilise Supabase Realtime pour la synchronisation
- Impl√©mente les operational transforms
- Affiche les curseurs et actions des autres utilisateurs

üí° **Tips Windsurf :** Utilise Yjs pour les CRDT. Impl√©mente des indicateurs de pr√©sence. G√®re la reconnexion automatique.

---

### 22 - Application mobile et notifications push

üéØ **But :** D√©velopper l'application mobile native avec synchronisation et notifications push avanc√©es.

üß† **Contexte technique :** L'application mobile √©tend l'acc√®s au calendrier avec des fonctionnalit√©s optimis√©es pour mobile. Elle doit synchroniser avec le web, g√©rer les notifications push et fonctionner hors-ligne.

üõ†Ô∏è **Type de fichier :** `.tsx` (React Native)

üîÑ **Comportement attendu :**
Cr√©er l'application mobile avec React Native, synchronisation offline-first et notifications push natives.

‚öôÔ∏è **Interactions :** 
- Synchronise avec l'API Supabase
- Utilise les notifications push natives
- Fonctionne en mode hors-ligne

üí° **Tips Windsurf :** Utilise Expo pour le d√©veloppement rapide. Impl√©mente Redux Persist pour l'√©tat offline. G√®re les permissions natives.

---

### 23 - Analytics avanc√©s et reporting

üéØ **But :** Cr√©er un syst√®me d'analytics avanc√© avec rapports personnalis√©s et insights m√©tier.

üß† **Contexte technique :** Les analytics fournissent des insights sur l'utilisation du calendrier, les patterns de r√©servation et les performances. Ils doivent √™tre configurables et exportables.

üõ†Ô∏è **Type de fichier :** `.tsx` et `.ts` (dashboards et services)

üîÑ **Comportement attendu :**
D√©velopper les analytics dans `src/modules/calendar-module/analytics/` avec dashboards interactifs, rapports automatis√©s et m√©triques personnalis√©es.

‚öôÔ∏è **Interactions :** 
- Int√®gre avec les donn√©es de tous les modules
- G√©n√®re des rapports automatis√©s
- Fournit des APIs pour les int√©grations

üí° **Tips Windsurf :** Utilise D3.js pour les visualisations avanc√©es. Impl√©mente des rapports programm√©s. G√®re l'anonymisation des donn√©es.

---

### 24 - Int√©gration IoT et automatisation venue

üéØ **But :** Connecter le calendrier avec les syst√®mes IoT des lieux pour automatisation et monitoring temps r√©el.

üß† **Contexte technique :** L'int√©gration IoT permet de contr√¥ler automatiquement l'√©clairage, la temp√©rature et autres syst√®mes des lieux selon les √©v√©nements planifi√©s. Elle doit √™tre s√©curis√©e et fiable.

üõ†Ô∏è **Type de fichier :** `.ts` (services IoT)

üîÑ **Comportement attendu :**
Cr√©er les services IoT dans `src/modules/calendar-module/iot/` avec protocoles de communication, automatisation et monitoring des √©quipements.

‚öôÔ∏è **Interactions :** 
- Connecte avec les syst√®mes IoT des lieux
- Automatise les configurations selon les √©v√©nements
- Monitore l'√©tat des √©quipements en temps r√©el

üí° **Tips Windsurf :** Utilise MQTT pour la communication IoT. Impl√©mente des protocoles s√©curis√©s. G√®re la tol√©rance aux pannes.

---

## üìä Matrice de Priorit√©s et D√©pendances

### **Phase 1 - Fondations Calendaires (P0)**
- **Prompts 01-06** : Infrastructure et base de donn√©es
- **Dur√©e estim√©e** : 2-3 semaines
- **D√©pendances** : Module Dashboard (sidebar), Console Admin (permissions)

### **Phase 2 - Interface Principale (P0)**
- **Prompts 07-12** : Composants principaux et grille calendaire
- **Dur√©e estim√©e** : 3-4 semaines
- **D√©pendances** : Phase 1, Module √âv√©nement (donn√©es)

### **Phase 3 - Fonctionnalit√©s Avanc√©es (P1)**
- **Prompts 13-18** : Statistiques, synchronisation et vues alternatives
- **Dur√©e estim√©e** : 2-3 semaines
- **D√©pendances** : Phase 2, int√©grations externes

### **Phase 4 - √âvolutions Futures (P2-P3)**
- **Prompts 19-24** : IA, collaboration et IoT
- **Dur√©e estim√©e** : 4-6 semaines
- **D√©pendances** : Console IA, infrastructure avanc√©e

## üéØ Recommandations d'Ex√©cution

### **Ordre de D√©veloppement Optimal**
1. **Semaine 1-2** : Prompts 01-06 (Base technique solide)
2. **Semaine 3-5** : Prompts 07-09 (Interface principale)
3. **Semaine 6-7** : Prompts 10-12 (Grille et √©v√©nements)
4. **Semaine 8-9** : Prompts 13-15 (Fonctionnalit√©s secondaires)
5. **Semaine 10+** : Prompts 16-24 (√âvolutions selon priorit√©s m√©tier)

### **Points d'Attention Critiques**
- ‚ö†Ô∏è **Performance** : Optimiser le rendu pour de gros volumes d'√©v√©nements
- ‚ö†Ô∏è **Responsive** : Tester sur tous les formats d'√©cran
- ‚ö†Ô∏è **Accessibilit√©** : Respecter les standards WCAG 2.1
- ‚ö†Ô∏è **Int√©grations** : Valider la compatibilit√© avec les modules existants

### **Validation et Tests**
- **Tests unitaires** : Composants et utilitaires calendaires
- **Tests d'int√©gration** : Synchronisation avec modules √âv√©nement et Lieux
- **Tests de performance** : Rendu avec 1000+ √©v√©nements
- **Tests utilisateur** : Workflows de planification complets

